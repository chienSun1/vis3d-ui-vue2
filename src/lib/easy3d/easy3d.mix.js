"use strict"; function _interopDefault(t) { return t && "object" == typeof t && "default" in t ? t.default : t } var $ = _interopDefault(require("jquery")), axios = _interopDefault(require("axios")), L = require("leaflet"), MarkdownItSanitizer = (require("leaflet/dist/leaflet.css"), _interopDefault(require("markdown-it-sanitizer"))), MarkdownIt = _interopDefault(require("markdown-it")), Hammer = _interopDefault(require("hammerjs")); function cartesianToLnglat(t, e) { return t ? (e = (e = e || window.viewer).scene.globe.ellipsoid.cartesianToCartographic(t), t = Cesium.Math.toDegrees(e.latitude), [Cesium.Math.toDegrees(e.longitude), t, e.height]) : [] } function cartesiansToLnglats(t, e) { if (t && !(t.length < 1)) { e = e || window.viewer; for (var i = [], o = 0; o < t.length; o++)i.push(cartesianToLnglat(t[o], e)); return i } } function lnglatsToCartesians(t) { if (t && !(t.length < 1)) { for (var e = [], i = 0; i < t.length; i++) { var o = Cesium.Cartesian3.fromDegrees(t[i][0], t[i][1], t[i][2] || 0); e.push(o) } return e } } function flyTo(t, e) { var i; t && ((i = e.center) ? (e = e || {}, i instanceof Cesium.Cartesian3 && t.camera.flyToBoundingSphere(new Cesium.BoundingSphere(i), { offset: new Cesium.HeadingPitchRange(Cesium.Math.toRadians(e.heading || 0), Cesium.Math.toRadians(e.pitch || -60), e.range || 1e4) }), i instanceof Array && (i = new Cesium.BoundingSphere(Cesium.Cartesian3.fromDegrees(i[0], i[1], i[2])), t.camera.flyToBoundingSphere(i, { offset: new Cesium.HeadingPitchRange(Cesium.Math.toRadians(e.heading || 0), Cesium.Math.toRadians(e.pitch || -60), e.range || 1e4) }))) : console.log("缺少定位坐标！")) } function getCameraView(t) { var t = (t = t || window.viewer).camera, e = t.position, i = t.heading, o = t.pitch, t = t.roll, e = Cesium.Cartographic.fromCartesian(e); return { x: Cesium.Math.toDegrees(e.longitude), y: Cesium.Math.toDegrees(e.latitude), z: e.height, heading: Cesium.Math.toDegrees(i), pitch: Cesium.Math.toDegrees(o), roll: Cesium.Math.toDegrees(t) } } function setCameraView(t, e) { var i, e = e || window.viewer; t && (i = t.destination || Cesium.Cartesian3.fromDegrees(t.x, t.y, t.z), e.camera.flyTo({ destination: i, orientation: { heading: Cesium.Math.toRadians(t.heading || 0), pitch: Cesium.Math.toRadians(t.pitch || 0), roll: Cesium.Math.toRadians(t.roll || 0) }, duration: void 0 === t.duration ? 3 : t.duration, complete: t.complete })) } function oreatationToHpr(o, s, n) { if (o && s) { var r = new Cesium.Matrix3, s = Cesium.Matrix3.fromQuaternion(s, r), r = Cesium.Matrix4.fromRotationTranslation(s, o, new Cesium.Matrix4); let { heading: t, pitch: e, roll: i } = Cesium.Transforms.fixedFrameToHeadingPitchRoll(r, Cesium.Ellipsoid.WGS84, Cesium.Transforms.eastNorthUpToFixedFrame, new Cesium.HeadingPitchRoll); return n && (t = Cesium.Math.toDegrees(t), e = Cesium.Math.toDegrees(e), i = Cesium.Math.toDegrees(i)), { heading: t, pitch: e, roll: i } } } var PI = 3.141592653589793, a = 6378245, ee = .006693421622965943; function transformWD(t, e) { var i = 2 * t - 100 + 3 * e + .2 * e * e + .1 * t * e + .2 * Math.sqrt(Math.abs(t)); return (i += 2 * (20 * Math.sin(6 * t * PI) + 20 * Math.sin(2 * t * PI)) / 3) + 2 * (20 * Math.sin(e * PI) + 40 * Math.sin(e / 3 * PI)) / 3 + 2 * (160 * Math.sin(e / 12 * PI) + 320 * Math.sin(e * PI / 30)) / 3 } function transformJD(t, e) { e = 300 + t + 2 * e + .1 * t * t + .1 * t * e + .1 * Math.sqrt(Math.abs(t)); return (e += 2 * (20 * Math.sin(6 * t * PI) + 20 * Math.sin(2 * t * PI)) / 3) + 2 * (20 * Math.sin(t * PI) + 40 * Math.sin(t / 3 * PI)) / 3 + 2 * (150 * Math.sin(t / 12 * PI) + 300 * Math.sin(t / 30 * PI)) / 3 } function wgs2gcj(t) { var e = Number(t[0]), t = Number(t[1]), i = transformWD(e - 105, t - 35), o = transformJD(e - 105, t - 35), s = t / 180 * PI, n = Math.sin(s), n = 1 - ee * n * n, r = Math.sqrt(n), t = t + 180 * i / (a * (1 - ee) / (n * r) * PI), i = e + 180 * o / (a / r * Math.cos(s) * PI); return [i = Number(i.toFixed(6)), t = Number(t.toFixed(6))] } function gcj2wgs(t) { var e = Number(t[0]), t = Number(t[1]), i = transformWD(e - 105, t - 35), o = transformJD(e - 105, t - 35), s = t / 180 * PI, n = Math.sin(s), n = 1 - ee * n * n, r = Math.sqrt(n), i = 180 * i / (a * (1 - ee) / (n * r) * PI), n = 2 * e - (e + 180 * o / (a / r * Math.cos(s) * PI)), e = 2 * t - (t + i); return [n = Number(n.toFixed(6)), e = Number(e.toFixed(6))] } function lerpPositions(t) { if (t && 0 != t.length) { var e = Cesium.PolylinePipeline.generateArc({ positions: t, granularity: 1e-5 }); if (e) { for (var i = [], o = 0; o < e.length; o += 3) { var s = Cesium.Cartesian3.unpack(e, o); i.push(s) } return i } } } function getIntersectPosition(e, i) { let o = i.startPoint, s = i.endPoint; if (o && s) { let t = Cesium.Cartesian3.subtract(s.clone(), o.clone(), new Cesium.Cartesian3); t = Cesium.Cartesian3.normalize(t, new Cesium.Cartesian3); i = new Cesium.Ray(o.clone(), t.clone()), e = e.scene.pickFromRay(i); return e ? e.position : null } console.log("缺少坐标！") } function getCirclePoints(o, s, t) { var n = Cesium.Cartesian3.distance(o.clone(), s.clone()); let r = []; for (let i = 0; i < 360; i += t) { var a = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(i), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0)), a = Cesium.Transforms.headingPitchRollToFixedFrame(o.clone(), a), a = Cesium.Matrix4.getMatrix3(a, new Cesium.Matrix3); let t = Cesium.Matrix3.multiplyByVector(a, s.clone(), new Cesium.Cartesian3), e = Cesium.Cartesian3.subtract(t.clone(), o.clone(), new Cesium.Cartesian3); e = Cesium.Cartesian3.normalize(e, new Cesium.Cartesian3), e = Cesium.Cartesian3.multiplyByScalar(e, n, new Cesium.Cartesian3), t = Cesium.Cartesian3.add(o.clone(), e.clone(), new Cesium.Cartesian3); a = Cesium.Cartographic.fromCartesian(t.clone()); r.push(a) } return r.unshift(), r } function getCirclePointsByRadius(t, e) { let { center: s, radius: n, angle: r } = e || {}; if (s && n) { r = r || 60; let i = []; var a = Cesium.Transforms.eastNorthUpToFixedFrame(s.clone()), e = Cesium.Matrix4.inverse(a, new Cesium.Matrix4), e = Cesium.Matrix4.multiplyByPoint(e, s.clone(), new Cesium.Cartesian3); let o = Cesium.Cartesian3.add(e, new Cesium.Cartesian3(n, 0, 0), new Cesium.Cartesian3); for (let e = 0; e <= 360; e += r) { var l = Cesium.Math.toRadians(e), l = Cesium.Matrix3.fromRotationZ(l); let t = Cesium.Matrix3.multiplyByVector(l, o.clone(), new Cesium.Cartesian3); t = Cesium.Matrix4.multiplyByPoint(a, t.clone(), new Cesium.Cartesian3), i.push(t) } return i } } function computeAngle(t, e) { var i = t.longitude, t = t.latitude, o = e.longitude, e = e.latitude, s = Math.sin(o - i) * Math.cos(e), t = Math.cos(t) * Math.sin(e) - Math.sin(t) * Math.cos(e) * Math.cos(o - i), e = Math.atan2(s, t); return (e = 180 * e / Math.PI) < -180 && (e += 360), e } function updatePositionsHeight(t, e) { if (t && null != e) { for (var i = [], o = 0; o < t.length; o++) { var s = cartesianToLnglat(t[o]), s = Cesium.Cartesian3.fromDegrees(s[0], s[1], e); i.push(s) } return i } } function computeUniforms(t, e, i) { if (t) { e = e || 1e3; var t = new Cesium.PolygonGeometry.fromPositions({ positions: t, vertexFormat: Cesium.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT, granularity: Math.PI / Math.pow(2, 11) / e }), o = new Cesium.PolygonGeometry.createGeometry(t), s = o.indices, n = o.attributes.position, r = { uniformArr: [] }; r.minHeight = Number.MAX_VALUE, r.maxHeight = Number.MIN_VALUE; for (var a = 0; a < s.length; a += 3) { var l = {}, h = s[a], c = s[a + 1], d = s[a + 2], h = new Cesium.Cartesian3(n.values[3 * h], o.attributes.position.values[3 * h + 1], n.values[3 * h + 2]), u = (i ? get3dtilesHeight : getTerrainHeight)(h), c = new Cesium.Cartesian3(n.values[3 * c], o.attributes.position.values[3 * c + 1], n.values[3 * c + 2]), p = (i ? get3dtilesHeight : getTerrainHeight)(c), d = new Cesium.Cartesian3(o.attributes.position.values[3 * d], o.attributes.position.values[3 * d + 1], n.values[3 * d + 2]), m = (i ? get3dtilesHeight : getTerrainHeight)(d); l.height = (u + p + m) / 3, r.minHeight > l.height && (r.minHeight = l.height), r.maxHeight < l.height && (r.maxHeight = l.height), l.area = computeAreaOfTriangle(h, c, d), r.uniformArr.push(l) } return r } } function getTerrainHeight(t) { if (t) return viewer.scene.globe.getHeight(Cesium.Cartographic.fromCartesian(t)) } function get3dtilesHeight(t) { if (t) return viewer.scene.sampleHeight(Cesium.Cartographic.fromCartesian(t)) } function computeAreaOfTriangle(t, e, i) { var o; return t && e && i ? (t = ((o = Cesium.Cartesian3.distance(t, e)) + (e = Cesium.Cartesian3.distance(e, i)) + (i = Cesium.Cartesian3.distance(i, t))) / 2, Math.sqrt(t * (t - o) * (t - e) * (t - i))) : (console.log("传入坐标有误！"), 0) } function getSlopePosition(n, r, a, l) { if (n && r) { let e = getCirclePointsByRadius(n, { center: r, radius: a || 10, angle: l || 10 }), i = Number.MAX_VALUE; n = getTerrainHeight(r.clone()); let o = -1; for (let t = 0; t < e.length; t++) { var h = getTerrainHeight(e[t]); i > h && (i = h, o = t) } let t, s; s = (i < n ? (t = r.clone(), e[o]) : (t = e[o].clone(), r)).clone(); a = Cesium.Cartographic.fromCartesian(t), l = Cesium.Cartographic.fromCartesian(s), r = (t = Cesium.Cartesian3.fromRadians(a.longitude, a.latitude, i < n ? n : i), s = Cesium.Cartesian3.fromRadians(l.longitude, l.latitude, i < n ? i : n), Cesium.Cartesian3.distance(t, s)), a = Math.abs(n - i), l = Math.acos(a / r), n = Cesium.Math.toDegrees(l); return { startP: t, endP: s, slope: n } } } var cUtil$1 = { getSlopePosition: getSlopePosition, getCirclePointsByRadius: getCirclePointsByRadius, updatePositionsHeight: updatePositionsHeight, computeUniforms: computeUniforms, cartesianToLnglat: cartesianToLnglat, cartesiansToLnglats: cartesiansToLnglats, lnglatsToCartesians: lnglatsToCartesians, flyTo: flyTo, getCameraView: getCameraView, setCameraView: setCameraView, wgs2gcj: wgs2gcj, gcj2wgs: gcj2wgs, lerpPositions: lerpPositions, oreatationToHpr: oreatationToHpr, getIntersectPosition: getIntersectPosition, getCirclePoints: getCirclePoints, computeAngle: computeAngle }; function downloadCanvasIamge(t, e) { var t = t.toDataURL("image/png"), i = (console.log(t), document.createElement("a")), o = new MouseEvent("click"); i.download = e || "下载图片名称", i.href = t, i.dispatchEvent(o) } let file = { _download(t, e) { var i = document.createElement("a"); i.download = t, i.href = URL.createObjectURL(e), document.body.appendChild(i), i.click(), document.body.removeChild(i) }, downloadFile(t, e) { e = new Blob([e]); this._download(t, e) }, downloadImage(t, e) { e = e.toDataURL("image/png"), e = this.base64Img2Blob(e); this._download(t + ".png", e) }, base64Img2Blob(t) { for (var t = t.split(";base64,"), e = t[0].split(":")[1], i = window.atob(t[1]), o = i.length, s = new Uint8Array(o), n = 0; n < o; ++n)s[n] = i.charCodeAt(n); return new Blob([s], { type: e }) } }; var cTool = { downloadCanvasIamge: downloadCanvasIamge, file: file }; class Prompt$1 {
    constructor(s, n) {
        if (this.viewer = s, this.viewer) {
            this.type = "prompt"; var s = null == (n = n || {}).type ? 1 : n.type, r = { id: (new Date).getTime() + "" + Math.floor(1e4 * Math.random()), type: s, anchor: 2 == s, closeBtn: 2 == s, offset: 2 == s ? { x: 0, y: -20 } : { x: 30, y: 20 }, content: "", show: !0, style: { background: "rgba(0,0,0,0.5)", color: "white" } }, r = (this.opt = Object.assign(r, n), this.viewer.container.id); this.isShow = null == this.opt.show || this.opt.show; let t = "", e = ""; var n = this.opt.style.background, a = this.opt.style.color, l = (this.opt.anchor && (t += `
            <div class="prompt-anchor-container">
                <div class="prompt-anchor" style="background:${n} !important;">
                </div>
            </div>
            `), this.opt.closeBtn && (e = `<a class="prompt-close" attr="${this.opt.id}" id="prompt-close-${this.opt.id}" href="#close">x</a>`), this.opt.style.boxShadow), h = "prompt-" + this.opt.id, n = `
                <!-- 文本内容 -->
                <div class="prompt-content-container" style="background:${n} !important;color:${a} !important;box-shadow:${l}">
                    <div class="prompt-content" id="prompt-content-${this.opt.id}">
                        ${this.opt.content}
                    </div>
                </div>
                <!-- 锚 -->
                ${t}
                <!-- 关闭按钮 -->
                ${e}
        `; this.promptDiv = window.document.createElement("div"), this.promptDiv.className = "easy3d-prompt", this.promptDiv.id = h, this.promptDiv.innerHTML = n; let i = window.document.getElementById(r); i.appendChild(this.promptDiv); const c = window.document.getElementById("prompt-close-" + this.opt.id); let o = this; c && c.addEventListener("click", t => { o.hide(), o.close && o.close() }), this.promptDom = window.document.getElementById(h), this.contentW = this.promptDom.offsetWidth, this.contentH = this.promptDom.offsetHeight, this.position = this.transPosition(this.opt.position), 2 == s && this.bindRender(), 0 == this.opt.show && this.hide(), this.containerW = this.viewer.container.offsetWidth, this.containerH = this.viewer.container.offsetHeight, this.containerLeft = this.viewer.container.offsetLeft, this.containerTop = this.viewer.container.offsetTop
        }
    } destroy() { this.promptDiv && (window.document.getElementById(this.viewer.container.id).removeChild(this.promptDiv), this.promptDiv = null), this.rendHandler && (this.rendHandler(), this.rendHandler = null) } bindRender() { let i = this; this.rendHandler = this.viewer.scene.postRender.addEventListener(function () { if (!i.isShow && i.promptDom) i.promptDom.style.display = "none"; else if (i.position) if (i.position instanceof Cesium.Cartesian3) { var t = Cesium.SceneTransforms.wgs84ToWindowCoordinates(i.viewer.scene, i.position); if (t) { const e = new Cesium.EllipsoidalOccluder(i.viewer.scene.globe.ellipsoid, i.viewer.scene.camera.position); e.isPointVisible(i.position) ? i.promptDom && (i.promptDom.style.display = "block") : i.promptDom && (i.promptDom.style.display = "none"), i.setByPX({ x: t.x, y: t.y }) } } else i.setByPX({ x: i.position.x, y: i.position.y }) }, this) } update(t, e) { t instanceof Cesium.Cartesian3 && (this.position = t.clone(), t = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, t)), t && this.setByPX(t), e && this.setContent(e) } isInView() { if (!this.position) return !1; let t = null; t = this.position instanceof Cesium.Cartesian2 ? this.position : Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, this.position); const e = new Cesium.EllipsoidalOccluder(this.viewer.scene.globe.ellipsoid, this.viewer.scene.camera.position); var i = e.isPointVisible(this.position); let o = !1; return (!t || (t.x > this.containerLeft && t.x < this.containerLeft + this.containerW && t.y > this.containerTop && t.y < this.containerTop + this.containerH && (o = !0), i)) && o } setVisible(t) { this.isInView(this.position) && t ? (this.isShow = !0, this.promptDom && (this.promptDom.style.display = "block")) : (this.isShow = !1, this.promptDom && (this.promptDom.style.display = "none")) } show() { this.setVisible(!0) } hide() { this.setVisible(!1) } setContent(t) { let e = window.document.getElementById("prompt-content-" + this.opt.id); e.innerHTML = t } setByPX(t) { t && this.promptDom && (this.promptDom.style.left = Number(t.x) + Number(this.opt.offset.x || 0) - Number(this.contentW) / 2 + "px", this.promptDom.style.top = Number(t.y) + Number(this.opt.offset.y || 0) - Number(this.contentH) + "px") } transPosition(t) { let e; if (Array.isArray(t)) { const i = Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2] || 0); e = i.clone() } return e = t instanceof Cesium.Cartesian3 ? t.clone() : t }
} class BasePlot { constructor(t, e) { this.viewer = t, this.style = (e = e || {}) || {}, this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.positions = [], this.state = null, this.prompt = null, this.controlPoints = [], this.modifyPoint = null, this.entity = null, this.pointStyle = {}, this.promptStyle = e.prompt || { show: !0, offset: { x: 30, y: 30 } }, this.properties = {} } getCatesian3FromPX(t) { var e = this.viewer.scene.drillPick(t); this.viewer.scene.render(); let i, o = !1; for (let t = 0; t < e.length; t++)if (e[t] && e[t].primitive && e[t].primitive instanceof Cesium.Cesium3DTileset) { o = !0; break } if (o) i = this.viewer.scene.pickPosition(t); else { t = this.viewer.camera.getPickRay(t); if (!t) return null; i = this.viewer.scene.globe.pick(t, this.viewer.scene) } return i } getEntity() { return this.entity } getPositions(t) { return t ? cUtil$1.cartesiansToLnglats(this.positions, this.viewer) : this.positions } setOwnProp(t) { this.entity && (this.entity.ownProp = t) } remove() { this.entity && (this.state = "no", this.viewer.entities.remove(this.entity), this.entity = null) } setVisible(t) { this.entity.show = t } forbidDrawWorld(t) { this.viewer.scene.screenSpaceCameraController.enableRotate = !t, this.viewer.scene.screenSpaceCameraController.enableTilt = !t, this.viewer.scene.screenSpaceCameraController.enableTranslate = !t, this.viewer.scene.screenSpaceCameraController.enableInputs = !t } destroy() { this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.entity && (this.viewer.entities.remove(this.entity), this.entity = null), this.positions = [], this.style = null; for (var t = 0; t < this.controlPoints.length; t++) { var e = this.controlPoints[t]; this.viewer.entities.remove(e) } this.controlPoints = [], this.modifyPoint = null, this.prompt && (this.prompt.destroy(), this.prompt = null), this.state = "no", this.forbidDrawWorld(!1) } startEdit(t) { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let i = this; for (let e = 0; e < i.controlPoints.length; e++) { let t = i.controlPoints[e]; t && (t.show = !0) } this.entity.show = !0, this.modifyHandler.setInputAction(function (t) { i.entity && (t = i.viewer.scene.pick(t.position), Cesium.defined(t) && t.id && (t.id.objId || (i.modifyPoint = t.id), i.forbidDrawWorld(!0))) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (t) { i.positions.length < 1 || !i.modifyPoint || (t = i.getCatesian3FromPX(t.endPosition, i.viewer, [i.entity, i.modifyPoint])) && (i.modifyPoint.position.setValue(t), i.positions[i.modifyPoint.wz] = t, i.state = "editing") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { i.modifyPoint && (i.modifyPoint = null, i.forbidDrawWorld(!1), i.state = "editing") }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { for (let e = 0; e < this.controlPoints.length; e++) { let t = this.controlPoints[e]; t && (t.show = !1) } this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createPoint(i) { if (i) { this.pointStyle.color = this.pointStyle.color || Cesium.Color.CORNFLOWERBLUE, this.pointStyle.outlineColor = this.pointStyle.color || Cesium.Color.CORNFLOWERBLUE; let t = this.pointStyle.color instanceof Cesium.Color ? this.pointStyle.color : Cesium.Color.fromCssColorString(this.pointStyle.color), e = (t = t.withAlpha(this.pointStyle.colorAlpha || 1), this.pointStyle.outlineColor instanceof Cesium.Color ? this.pointStyle.outlineColor : Cesium.Color.fromCssColorString(this.pointStyle.outlineColor)); return e = e.withAlpha(this.pointStyle.outlineColorAlpha || 1), this.viewer.entities.add({ position: i, point: { pixelSize: this.pointStyle.property || 10, color: t, outlineWidth: this.pointStyle.outlineWidth || 0, outlineColor: e, disableDepthTestDistance: Number.POSITIVE_INFINITY }, show: !1 }) } } transfromLineMaterial(e) { if (e) { let t = {}; return e instanceof Cesium.Color && (e = e.color.getValue(), t.colorAlpha = e.alpha, t.colorHex = new Cesium.Color(e.red, e.green, e.blue, 1).toCssHexString()), t } } transfromGonMaterial(e) { if (e) { let t = {}; return e instanceof Cesium.Color && (e = e.color.getValue(), t.colorAlpha = e.alpha, t.colorHex = new Cesium.Color(e.red, e.green, e.blue, 1).toCssHexString()), t } } setAttr(t) { this.properties.attr = t || {} } zoomTo() { this.entity && this.viewer.zoomTo(this.entity) } } class CreateBillboard extends BasePlot { constructor(t, e) { super(t, e), this.type = "billboard", this.viewer = t; t = { verticalOrigin: Cesium.VerticalOrigin.BOTTOM, scale: 1 }; this.style = Object.assign({}, t, e || {}), this.entity = null, this.style.hasOwnProperty("image") || console.log("未设置billboard的参数！"), this.position = null } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let o = this; this.handler.setInputAction(function (t) { let e = o.getCatesian3FromPX(t.position, o.viewer); e && (o.position = e.clone(), o.entity = o.createBillboard(o.position), o.handler && (o.handler.destroy(), o.handler = null), o.prompt && (o.prompt.destroy(), o.prompt = null), o.state = "endCreate", i && i(o.entity)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { o.prompt.update(t.endPosition, "单击新增"), o.state = "startCreate" }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } createByPositions(e, i) { if (e) { this.state = "startCreate"; let t = null; (t = e instanceof Cesium.Cartesian3 ? e.clone() : Cesium.Cartesian3.fromDegrees(Number(e[0]), Number(e[1]), Number(e[2] || 0))) && (this.position = t.clone(), this.entity = this.createBillboard(this.position), i && i(this.entity), this.state = "endCreate") } } setStyle(i) { if (i) { let e = this.entity.billboard; if (null != i.image && (e.image = i.image), null != i.heightReference) { let t = 1; t = 1 == this.style.heightReference ? 1 : this.style.heightReference, e.heightReference = t } if (null != i.heightReference && (e.heightReference = null == i.heightReference ? 1 : Number(this.style.heightReference)), null != i.scale && (e.scale = Number(i.scale)), i.color) { let t = i.color instanceof Cesium.Color ? i.color : Cesium.Color.fromCssColorString(i.color); t = t.withAlpha(i.colorAlpha || 1), e.color = t } this.style = Object.assign(this.style, i) } } getStyle() { let t = {}, e = this.entity.billboard; var i; return t.image = this.style.image, e.heightReference && (i = e.heightReference.getValue(), t.heightReference = Boolean(i)), t.scale = e.scale.getValue(), e.color && (i = e.color.getValue(), t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString()), t } startEdit() { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let i = this, o; this.modifyHandler.setInputAction(function (t) { t = i.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (o = t.id, i.forbidDrawWorld(!0)) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (e) { if (o) { let t = i.getCatesian3FromPX(e.endPosition, i.viewer); t && (o.position.setValue(t.clone()), i.position = t.clone(), i.state = "editing") } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { o && (i.forbidDrawWorld(!1), i.modifyHandler && (i.modifyHandler.destroy(), i.modifyHandler = null, i.state = "editing")) }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.state = "endEdit" } createBillboard(e) { if (e) { let t = this.viewer.entities.add({ position: e, billboard: { color: this.style.color ? this.style.color instanceof Cesium.Color ? this.style.color : Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1) : Cesium.Color.WHITE, image: this.style.image || "../img/mark4.png", scale: this.style.scale || 1, pixelOffset: this.style.pixelOffset, heightReference: null == this.style.heightReference ? 1 : Number(this.style.heightReference), verticalOrigin: Cesium.VerticalOrigin.BOTTOM } }); return t.objId = this.objId, t } } remove() { this.entity && (this.state = "no", this.viewer.entities.remove(this.entity), this.entity = null) } getPositions(t) { return t ? cUtil$1.cartesianToLnglat(this.position, this.viewer) : this.position } setPosition(t) { let e = null; e = t instanceof Cesium.Cartesian3 ? t : Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2] || 0), this.entity.position.setValue(e.clone()), this.position = e.clone() } } class CreateCircle extends BasePlot { constructor(t, e) { super(t, e), this.type = "circle", this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.viewer = t, this.style = e, this.floatPoint = null, this.centerPoint = null, this.position = null, this.floatPosition = null, this.radius = .001, this.modifyPoint = null, this.pointArr = [] } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let o = this; this.handler.setInputAction(function (t) { let e = o.getCatesian3FromPX(t.position, o.viewer); e && (o.centerPoint ? o.entity && (o.floatPosition = e.clone(), o.state = "endCreate", o.handler && (o.handler.destroy(), o.handler = null), o.floatPoint && (o.floatPoint.show = !1), o.centerPoint && (o.centerPoint.show = !1), o.prompt && (o.prompt.destroy(), o.prompt = null), i && i(o.entity)) : (o.position = e, o.centerPoint = o.createPoint(e), o.centerPoint.typeAttr = "center", o.floatPoint = o.createPoint(e.clone()), o.floatPosition = e.clone(), o.floatPoint.typeAttr = "float", o.entity = o.createCircle(o.position, o.radius))) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (e) { if (o.centerPoint) { o.state = "creating", o.prompt.update(e.endPosition, "再次单击结束"); let t = o.getCatesian3FromPX(e.endPosition, o.viewer); t && (o.floatPoint && (o.floatPoint.position.setValue(t), o.floatPosition = t.clone()), o.radius = Cesium.Cartesian3.distance(t, o.position)) } else o.prompt.update(e.endPosition, "单击开始绘制") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } createByPositions(e, t) { if (e && !(e.length < 1)) { if (this.state = "startCreate", Array.isArray(e)) { var i = e[0] instanceof Cesium.Cartesian3; let t = []; if (!(t = i ? e : cUtil$1.lnglatsToCartesians(e)) || t.length < 1) return; this.position = t[0].clone(), this.radius = Cesium.Cartesian3.distance(this.position, t[1]), this.floatPosition = t[1].clone() } else this.position = e.position, this.radius = e.radius, this.floatPosition = cUtil$1.getPositionByLength(); this.centerPoint = this.createPoint(this.position), this.centerPoint.typeAttr = "center", this.floatPoint = this.createPoint(this.float), this.floatPoint.typeAttr = "float", this.entity = this.createCircle(this.position, this.radius), this.state = "endCreate", t && t(this.entity) } } startEdit(e) { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let i = this; i.floatPoint && (i.floatPoint.show = !0), i.centerPoint && (i.centerPoint.show = !0), this.modifyHandler.setInputAction(function (t) { i.entity && (i.state = "editing", t = i.viewer.scene.pick(t.position), Cesium.defined(t) && t.id ? (t.id.objId || (i.modifyPoint = t.id), i.forbidDrawWorld(!0)) : (i.floatPoint && (i.floatPoint.show = !1), i.centerPoint && (i.centerPoint.show = !1), i.modifyHandler && (i.modifyHandler.destroy(), i.modifyHandler = null, e && e(i.entity)))) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (t) { var e; !i.modifyPoint || (t = i.getCatesian3FromPX(t.endPosition, i.viewer)) && (i.state = "editing", "center" == i.modifyPoint.typeAttr ? (e = Cesium.Cartesian3.subtract(t, i.position, new Cesium.Cartesian3), i.position = t, i.centerPoint.position.setValue(i.position), i.entity.position.setValue(i.position), i.floatPosition = Cesium.Cartesian3.add(i.float, e, new Cesium.Cartesian3), i.floatPoint.position.setValue(i.float)) : (i.floatPosition = t, i.floatPoint.position.setValue(i.float), i.radius = Cesium.Cartesian3.distance(i.float, i.position))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { i.modifyPoint && (i.modifyPoint = null, i.forbidDrawWorld(!1), i.state = "editing") }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.floatPoint && (this.floatPoint.show = !1), this.centerPoint && (this.centerPoint.show = !1), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createCircle() { let t = this, e = { semiMajorAxis: new Cesium.CallbackProperty(function () { return t.radius }, !1), semiMinorAxis: new Cesium.CallbackProperty(function () { return t.radius }, !1), material: this.style.color instanceof Cesium.Color ? this.style.color : this.style.color ? Cesium.Color.fromCssColorString(this.style.color).withAlpha(this.style.colorAlpha || 1) : Cesium.Color.WHITE, outlineColor: this.style.outlineColor instanceof Cesium.Color ? this.style.outlineColor : this.style.outlineColor ? Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1) : Cesium.Color.BLACK, outline: this.style.outline, outlineWidth: 1, fill: this.style.fill }, i = (this.style.heightReference && 0 != Number(this.style.heightReference) ? e.heightReference = 1 : (e.height = 100, e.heightReference = 0), this.viewer.entities.add({ position: this.position, ellipse: e })); return i.objId = this.objId, i } setStyle(i) { if (i) { let t = Cesium.Color.fromCssColorString(i.color || "#ffff00"), e = (t = t.withAlpha(i.colorAlpha), this.entity.ellipse.material = t, this.entity.ellipse.outline = i.outline, this.entity.ellipse.outlineWidth = i.outlineWidth, Cesium.Color.fromCssColorString(i.outlineColor || "#000000")); e = e.withAlpha(i.outlineColorAlpha), this.entity.ellipse.outlineColor = e, this.entity.ellipse.heightReference = Number(i.heightReference), 0 == i.heightReference && (this.entity.ellipse.height = Number(i.height), this.updatePointHeight(i.height)), this.entity.ellipse.fill = Boolean(i.fill), this.style = Object.assign(this.style, i) } } getStyle() { let t = {}, e = this.entity.ellipse; var i = e.material.color.getValue(), i = (t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), e.outline && (t.outline = e.outline.getValue()), t.outlineWidth = e.outlineWidth._value, e.outlineColor.getValue()); return t.outlineColorAlpha = i.alpha, t.outlineColor = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), e.height && (t.height = e.height.getValue()), e.fill && (t.fill = e.fill.getValue()), t.heightReference = e.heightReference.getValue(), t } destroy() { this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.entity && (this.viewer.entities.remove(this.entity), this.entity = null), this.floatPoint && (this.viewer.entities.remove(this.floatPoint), this.floatPoint = null), this.centerPoint && (this.viewer.entities.remove(this.centerPoint), this.centerPoint = null), this.style = null, this.modifyPoint = null, this.prompt && this.prompt.destroy(), this.forbidDrawWorld(!1), this.state = "no" } updatePointHeight(t) { var e = this.centerPoint.position.getValue(), i = this.floatPoint.position.getValue(), e = cUtil$1.updatePositionsHeight([e], Number(this.style.height))[0], i = cUtil$1.updatePositionsHeight([i], Number(this.style.height))[0]; this.centerPoint.position.setValue(e), this.floatPoint.position.setValue(i) } getPositions(t) { let e = []; return e = t ? cUtil$1.cartesiansToLnglats([this.position, this.floatPosition]) : [this.position, this.floatPosition] } } class CreateGltfModel extends BasePlot { constructor(t, e) { super(t, e), this.type = "gltfModel", e = e || {}, this.viewer = t, e.uri ? (this.style = Object.assign({ heading: 0, pitch: 0, roll: 0, minimumPixelSize: 24, maximumScale: 120 }, e || {}), this.modelUri = e.uri, this.entity = null) : console.warn("请输入模型地址！") } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let o = this; this.handler.setInputAction(function (t) { let e = o.getCatesian3FromPX(t.position, o.viewer); e && (o.entity.position = e, o.position = e.clone()), o.state = "endCreate", o.handler && (o.handler.destroy(), o.handler = null), o.prompt && (o.prompt.destroy(), o.prompt = null), i && i(o.entity) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { o.prompt.update(t.endPosition, "单击新增"); let e = o.getCatesian3FromPX(t.endPosition, o.viewer, [o.entity]); e && (o.entity ? o.entity.position = e : o.entity = o.createGltfModel(e.clone())) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } createByPositions(t, e) { t && (this.state = "startCreate", t instanceof Cesium.Cartesian3 ? this.position = t : this.position = Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2] || 0), this.entity = this.createGltfModel(this.position), e(this.entity), this.state = "endCreate") } startEdit() { if ("startEdit" != this.state && "editing" != this.state) { this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let i = this, o; this.state = "startEdit", this.modifyHandler.setInputAction(function (t) { t = i.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (o = t.id, i.forbidDrawWorld(!0)) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (e) { if (o) { let t = i.getCatesian3FromPX(e.endPosition, i.viewer, [i.entity]); t && (i.entity && (i.entity.position.setValue(t), i.position = t.clone()), i.state = "editing") } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { o && (i.forbidDrawWorld(!1), i.modifyHandler && (i.modifyHandler.destroy(), i.modifyHandler = null), i.state = "editing") }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createGltfModel(e) { if (e) { var i = Cesium.Math.toRadians(this.style.heading), o = Cesium.Math.toRadians(this.style.pitch), s = Cesium.Math.toRadians(this.style.roll), i = new Cesium.HeadingPitchRoll(i, o, s), o = Cesium.Transforms.headingPitchRollQuaternion(e, i); let t = this.viewer.entities.add({ position: e, orientation: o, model: { uri: this.modelUri, minimumPixelSize: this.style.minimumPixelSize, maximumScale: this.style.maximumScale, scale: this.style.scale || 1, heightReference: this.style.heightReference } }); return t.objId = this.objId, t } } getPositions(t) { return t ? cUtil$1.cartesianToLnglat(this.position, this.viewer) : this.position } getStyle() { let t = {}, e = this.entity.model; t.minimumPixelSize = e.minimumPixelSize.getValue(); var i = this.entity.orientation.getValue(); let o = this.entity.position.getValue(this.viewer.clock.currentTime); i = cUtil$1.oreatationToHpr(o.clone(), i, !0) || {}; return t.heading = (i.heading || 0) < 360 ? i.heading + 360 : i.heading, t.pitch = i.pitch || 0, t.roll = i.roll || 0, t.scale = e.scale.getValue(), t.uri = e.uri.getValue(), t } setStyle(t) { t && (this.setOrientation(t.heading, t.pitch, t.roll), this.entity.model.scale.setValue(null == t.scale ? 1 : t.scale), t.uri && this.entity.model.uri.setValue(t.uri), null != t.heightReference && this.entity.model.heightReference.setValue(Number(t.heightReference)), this.style = Object.assign(this.style, t)) } setOrientation(t, e, i) { e = e || 0, i = i || 0, this.style.heading = t = t || 0, this.style.pitch = e, this.style.roll = i; t = Cesium.Math.toRadians(t || 0), e = Cesium.Math.toRadians(e || 0), i = Cesium.Math.toRadians(i || 0), t = new Cesium.HeadingPitchRoll(t, e, i), e = this.entity.position._value, i = Cesium.Transforms.headingPitchRollQuaternion(e, t); this.entity && (this.entity.orientation = i) } remove() { this.entity && (this.state = "no", this.viewer.entities.remove(this.entity), this.entity = null) } destroy() { this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.entity && (this.viewer.entities.remove(this.entity), this.entity = null), this.style = null, this.prompt && (that.prompt.destroy(), this.prompt = null) } } class CreateLabel extends BasePlot {
    constructor(t, e) { super(t, e), this.type = "label", this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.viewer = t, this.style = e, this.position = null } start(s) {
        !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)); let n = this; this.state = "startCreate", this.handler.setInputAction(function (e) {
            let o = n.getCatesian3FromPX(e.position, n.viewer); if (o) {
                n.prompt.update(e.position, `
        <ul class="label-context-${n.objId}" objId="${n.objId}">
          <li>名称：<input type="text" objId="${n.objId}" id="label-name-${n.objId}" /></li>
          <li>
              <input type="button" value="确定" objId="${n.objId}" id="label-confirm-${n.objId}"/>
              <input type="button" value="取消" objId="${n.objId}" id="label-reset-${n.objId}"/>
          </li>
        <ul>
      `); let i = document.getElementById("label-confirm-" + n.objId), t = document.getElementById("label-reset-" + n.objId); i.addEventListener("click", function () { var t = i.getAttribute("objId"); const e = document.getElementById("label-name-" + t); t = e.innerText(); n.entity = n.createLabel(o, t), n.position = o, n.state = "endCreate", n.handler && (n.handler.destroy(), n.handler = null), n.prompt && (n.prompt.destroy(), n.prompt = null), s && s(n.entity) }), t.addEventListener("click", function () { t.getAttribute("objId"); n.destroy() })
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { n.prompt.update(t.endPosition, "单击新增"), n.state = "startCreate" }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)
    } createByPositions(t, e) { t && (this.state = "startCreate", t = t instanceof Cesium.Cartesian3 ? t : Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2]), (this.position = t) && (this.entity = this.createLabel(t, this.style.text), e && e(this.entity), this.state = "endCreate")) } setStyle(e) { if (e) { if (e.fillColor) { let t = e.fillColor instanceof Cesium.Color ? e.fillColor : Cesium.Color.fromCssColorString(e.fillColor || "#ffff00"); t = t.withAlpha(e.fillColorAlpha || 1), this.entity.label.fillColor = t } if (this.entity.label.outlineWidth = e.outlineWidth, e.backgroundColor) { let t = e.backgroundColor instanceof Cesium.Color ? e.backgroundColor : Cesium.Color.fromCssColorString(e.backgroundColor || "#000000"); t = t.withAlpha(e.backgroundColorAlpha || 1), this.entity.label.backgroundColor = t } null != e.heightReference && (this.entity.label.heightReference = Number(e.heightReference)), e.pixelOffset && (this.entity.label.pixelOffset = e.pixelOffset), e.text && (this.entity.label.text = e.text), null != e.showBackground && (this.entity.label.showBackground = Boolean(e.showBackground)), this.style = Object.assign(this.style, e) } } getStyle() { let t = {}, e = this.entity.label; var i = e.fillColor.getValue(), i = (t.fillColorAlpha = i.alpha, t.fillColor = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), t.outlineWidth = e.outlineWidth._value, e.backgroundColor.getValue()); return t.backgroundColorAlpha = i.alpha, t.backgroundColor = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), t.showBackground = Boolean(e.showBackground.getValue()), null != e.heightReference && (t.heightReference = e.heightReference.getValue()), t.pixelOffset = e.pixelOffset, t.text = e.text.getValue(), t } getPositions(t) { return t ? cUtil$1.cartesianToLnglat(this.position) : this.position } startEdit() { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let e = this, i; this.modifyHandler.setInputAction(function (t) { t = e.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (i = t.id, e.forbidDrawWorld(!0)) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (t) { !i || (t = e.getCatesian3FromPX(t.endPosition, e.viewer)) && e.entity && (e.entity.position.setValue(t), e.position = t, e.state = "editing") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { i && (e.forbidDrawWorld(!1), e.modifyHandler && (e.modifyHandler.destroy(), e.modifyHandler = null, e.state = "editing")) }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createLabel(e, i) { if (e) { let t = this.viewer.entities.add({ position: e, label: { text: i || "", fillColor: this.style.fillColor ? Cesium.Color.fromCssColorString(this.style.fillColor).withAlpha(this.style.fillColorAlpha || 1) : Cesium.Color.WHITE, backgroundColor: this.style.backgroundColor ? Cesium.Color.fromCssColorString(this.style.backgroundColor).withAlpha(this.style.backgroundColorAlpha || 1) : Cesium.Color.WHITE, style: Cesium.LabelStyle.FILL, outlineWidth: this.style.outlineWidth || 4, scale: this.style.scale || 1, pixelOffset: this.style.pixelOffset || Cesium.Cartesian2.ZERO, showBackground: this.style.showBackground, heightReference: this.style.heightReference || 0 } }); return t.objId = this.objId, t } }
} class CreatePoint extends BasePlot { constructor(t, e) { super(t, e), this.type = "point", this.viewer = t; t = { color: Cesium.Color.AQUA, pixelSize: 10, outlineWidth: 1 }; this.style = Object.assign(t, e || {}), this.position = null } start(e) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let i = this; this.handler.setInputAction(function (t) { t = i.getCatesian3FromPX(t.position, i.viewer); t && (i.entity = i.createPoint(t), i.position = t, i.state = "endCreate", i.handler && (i.handler.destroy(), i.handler = null), i.prompt && (i.prompt.destroy(), i.prompt = null), e && e(i.entity)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { i.prompt.update(t.endPosition, "单击新增"), i.state = "startCreate" }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } createByPositions(t, e) { t && (this.state = "startCreate", t = t instanceof Cesium.Cartesian3 ? t : Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2]), (this.position = t) && (this.entity = this.createPoint(t), e && e(this.entity), this.state = "endCreate")) } setStyle(e) { if (e) { if (e.color) { let t = Cesium.Color.fromCssColorString(e.color || "#ffff00"); t = t.withAlpha(e.colorAlpha), this.entity.point.color = t } if (this.entity.point.outlineWidth = Number(e.outlineWidth), e.outlineColor) { let t = Cesium.Color.fromCssColorString(e.outlineColor || "#000000"); t = t.withAlpha(e.outlineColorAlpha), this.entity.point.outlineColor = t } this.entity.point.heightReference = Number(e.heightReference), this.entity.point.pixelSize = Number(e.pixelSize), this.style = Object.assign(this.style, e) } } getStyle() { let t = {}, e = this.entity.point; var i = e.color.getValue(), i = (t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), t.outlineWidth = e.outlineWidth._value, e.outlineColor.getValue()); return t.outlineColorAlpha = i.alpha, t.outlineColor = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), null != e.heightReference && (t.heightReference = e.heightReference.getValue()), t.pixelSize = Number(e.pixelSize), t } getPositions(t) { return t ? cUtil$1.cartesianToLnglat(this.position) : this.position } startEdit() { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let e = this, i; this.modifyHandler.setInputAction(function (t) { t = e.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (i = t.id, e.forbidDrawWorld(!0)) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (t) { !i || (t = e.getCatesian3FromPX(t.endPosition, e.viewer)) && e.entity && (e.entity.position.setValue(t), e.position = t, e.state = "editing") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { i && (e.forbidDrawWorld(!1), e.modifyHandler && (e.modifyHandler.destroy(), e.modifyHandler = null, e.state = "editing")) }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createPoint(e) { if (e) { let t = this.viewer.entities.add({ position: e, point: { color: this.style.color instanceof Cesium.Color ? this.style.color : this.style.color ? Cesium.Color.fromCssColorString(this.style.color).withAlpha(this.style.colorAlpha || 1) : Cesium.Color.WHITE, outlineColor: this.style.outlineColor instanceof Cesium.Color ? this.style.outlineColor : this.style.outlineColor ? Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1) : Cesium.Color.BLACK, outlineWidth: this.style.outlineWidth || 4, pixelSize: this.style.pixelSize || 20 } }); return t.objId = this.objId, t } } } class CreatePolygon extends BasePlot { constructor(t, e) { super(t, e), this.type = "polygon", this.viewer = t, this.entity = null, this.polyline = null; this.style = Object.assign({ outlineColor: "#000000", outlineWidth: 2 }, e || {}), this.outline = null } start(e) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let i = this; this.handler.setInputAction(function (e) { e = i.getCatesian3FromPX(e.position, i.viewer, []); if (e) { i.movePush && (i.positions.pop(), i.movePush = !1), i.positions.push(e); let t = i.createPoint(e); t.wz = i.positions.length - 1, i.controlPoints.push(t) } }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { i.positions.length < 1 ? (i.prompt.update(t.endPosition, "单击开始绘制"), i.state = "startCreate") : (i.prompt && i.prompt.update(t.endPosition, "双击结束，右键取消上一步"), t = i.getCatesian3FromPX(t.endPosition, i.viewer, []), 1 <= i.positions.length && (i.state = "creating", i.movePush ? i.positions[i.positions.length - 1] = t : (i.positions.push(t), i.movePush = !0), 2 != i.positions.length || Cesium.defined(i.polyline) || (i.polyline = i.createPolyline()), 3 != i.positions.length || Cesium.defined(i.entity) || (i.entity = i.createPolygon(i.style), !i.style.outline && i.polyline && (i.polyline.show = !1), i.entity.objId = i.objId))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { i.entity && (i.positions.splice(i.positions.length - 2, 1), i.viewer.entities.remove(i.controlPoints.pop()), 2 == i.positions.length && i.entity && (i.viewer.entities.remove(i.entity), i.entity = null, i.polyline && (i.polyline.show = !0)), 1 == i.positions.length && (i.polyline && (i.viewer.entities.remove(i.polyline), i.polyline = null), i.prompt && i.prompt.update(t.endPosition, "单击开始绘制"), i.positions = [], i.movePush = !1)) }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.handler.setInputAction(function (t) { i.entity && (i.state = "endCreate", i.positions.pop(), i.viewer.entities.remove(i.controlPoints.pop()), i.handler && (i.handler.destroy(), i.handler = null), i.movePush = !1, i.prompt && (i.prompt.destroy(), i.prompt = null), i.viewer.trackedEntity = void 0, i.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), e && e(i.entity)) }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } createByPositions(t, e) { if (t) { this.state = "startCreate"; var s = t[0] instanceof Cesium.Cartesian3 ? t : cUtil$1.lnglatsToCartesians(t); if (s) { this.entity = this.createPolygon(), this.polyline = this.createPolyline(), this.polyline.show = this.style.outline, this.positions = s; for (let o = 0; o < s.length; o++) { let t = s[o], e = Cesium.Cartographic.fromCartesian(s[o]), i = (this.style.heightReference && (e.height = this.viewer.scene.sampleHeight(e), t = Cesium.Cartographic.toCartesian(e)), this.createPoint(t)); i.ctgc = e, i.wz = this.controlPoints.length, this.controlPoints.push(i) } this.state = "endCreate", this.entity.objId = this.objId, e && e(this.entity) } } } getStyle() { if (this.entity) { let t = {}, e = this.entity.polygon; var o; e.material instanceof Cesium.ColorMaterialProperty && (t.material = "common", o = e.material.color.getValue(), t.colorAlpha = o.alpha, t.color = new Cesium.Color(o.red, o.green, o.blue, 1).toCssHexString()), t.fill = !!e.fill && e.fill.getValue(), e.heightReference && (o = e.heightReference.getValue(), t.heightReference = Boolean(o)); let i = this.polyline.polyline; return i && this.polyline.show ? (t.outlineWidth = i.width.getValue(), t.outline = !0, o = i.material.color.getValue(), t.outlineColorAlpha = o.alpha, t.outlineColor = new Cesium.Color(o.red, o.green, o.blue, 1).toCssHexString()) : t.outline = !1, t } } setStyle(o) { if (o) { this.polyline.show = o.outline; let t = this.polyline.polyline, e = (t.width = o.outlineWidth, this.polyline.clampToGround = Boolean(o.heightReference), o.outlineColor instanceof Cesium.Color ? o.outlineColor : Cesium.Color.fromCssColorString(o.outlineColor)); var s = e.withAlpha(o.outlineColorAlpha || 1); t.material = s, null != o.heightReference && (this.entity.polygon.heightReference = Number(o.heightReference)); let i = o.color instanceof Cesium.Color ? o.color : Cesium.Color.fromCssColorString(o.color); s = i.withAlpha(o.colorAlpha || 1); this.entity.polygon.material = s, null != o.fill && (this.entity.polygon.fill = o.fill), this.style = Object.assign(this.style, o) } } createPolygon() { let t = this, e = (this.style.color = this.style.color || Cesium.Color.WHITE, this.style.outlineColor = this.style.outlineColor || Cesium.Color.BLACK, { polygon: { hierarchy: new Cesium.CallbackProperty(function () { return new Cesium.PolygonHierarchy(t.positions) }, !1), heightReference: Number(this.style.heightReference), show: !0, fill: this.style.fill || !0, material: this.style.color instanceof Cesium.Color ? this.style.color : Cesium.Color.fromCssColorString(this.style.color).withAlpha(this.style.colorAlpha || 1) } }); return this.style.heightReference || (e.polygon.height = 0, e.polygon.perPositionHeight = !0), this.viewer.entities.add(e) } createPolyline() { let t = this; return this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return t.positions.concat(t.positions[0]) }, !1), clampToGround: Boolean(this.style.heightReference), material: this.style.outlineColor instanceof Cesium.Color ? this.style.outlineColor : Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1), width: this.style.outlineWidth || 1 } }) } destroy() { this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.entity && (this.viewer.entities.remove(this.entity), this.entity = null), this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.positions = [], this.style = null, this.modifyPoint && (this.viewer.entities.remove(this.modifyPoint), this.modifyPoint = null); for (let t = 0; t < this.controlPoints.length; t++) { var e = this.controlPoints[t]; this.viewer.entities.remove(e) } this.controlPoints = [], this.state = "no", this.prompt && this.prompt.destroy(), this.polyline && (this.polyline = null, this.viewer.entities.remove(this.polyline)), this.forbidDrawWorld(!1) } } class CreateRectangle extends BasePlot { constructor(t, e) { super(t, e), this.type = "rectangle", this.viewer = t, this.style = e, this.rightdownPoint = null, this.leftupPoint = null, this.leftup = null, this.rightdown = null, this.radius = 0, this.modifyPoint = null, this.pointArr = [] } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let o = this; this.handler.setInputAction(function (t) { let e = o.getCatesian3FromPX(t.position, o.viewer, []); e && (o.leftupPoint ? o.entity && (o.state = "endCreate", o.handler && (o.handler.destroy(), o.handler = null), o.rightdownPoint && (o.rightdownPoint.show = !1), o.leftupPoint && (o.leftupPoint.show = !1), o.prompt && (o.prompt.destroy(), o.prompt = null), i && i(o.entity)) : (o.leftup = e, o.leftupPoint = o.createPoint(e), o.leftupPoint.typeAttr = "leftup", o.rightdownPoint = o.createPoint(e.clone()), o.rightdown = e.clone(), o.rightdownPoint.typeAttr = "rightdown", o.entity = o.createRectangle(o.leftup, o.radius))) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (e) { if (o.leftupPoint) { o.prompt.update(e.endPosition, "单击结束"); let t = o.getCatesian3FromPX(e.endPosition, o.viewer, []); t && (o.rightdownPoint && (o.rightdownPoint.position.setValue(t), o.rightdown = t.clone(), o.state = "creating"), o.radius = Cesium.Cartesian3.distance(t, o.leftup)) } else o.prompt.update(e.endPosition, "单击开始绘制"), o.state = "startCreate" }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } startEdit(t) { if ("startEdit" != this.state && "editing" != this.state && this.entity) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let e = this; e.rightdownPoint && (e.rightdownPoint.show = !0), e.leftupPoint && (e.leftupPoint.show = !0), this.modifyHandler.setInputAction(function (t) { e.entity && (t = e.viewer.scene.pick(t.position), Cesium.defined(t) && t.id && (t.id.objId || (e.modifyPoint = t.id), e.forbidDrawWorld(!0))) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (t) { !e.modifyPoint || (t = e.getCatesian3FromPX(t.endPosition, e.viewer, [e.entity, e.modifyPoint])) && (e.state, "leftup" == e.modifyPoint.typeAttr ? (e.leftup = t, e.leftupPoint.position.setValue(e.leftup), e.entity.position.setValue(e.leftup)) : (e.rightdown = t, e.rightdownPoint.position.setValue(e.rightdown)), e.radius = Cesium.Cartesian3.distance(e.rightdown, e.leftup)) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { e.modifyPoint && (e.modifyPoint = null, e.forbidDrawWorld(!1), e.state) }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit(t) { this.rightdownPoint && (this.rightdownPoint.show = !1), this.leftupPoint && (this.leftupPoint.show = !1), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null, t && t(this.entity)), this.forbidDrawWorld(!1), this.state = "endEdit" } createRectangle() { let t = this, e = this.viewer.entities.add({ rectangle: { coordinates: new Cesium.CallbackProperty(function () { return Cesium.Rectangle.fromCartesianArray([t.leftup, t.rightdown]) }, !1), heightReference: this.style.heightReference || 0, show: !0, fill: this.style.fill || !0, material: this.style.color instanceof Cesium.Color ? this.style.color : this.style.color ? Cesium.Color.fromCssColorString(this.style.color).withAlpha(this.style.colorAlpha || 1) : Cesium.Color.WHITE, outlineColor: this.style.outlineColor instanceof Cesium.Color ? this.style.outlineColor : this.style.outlineColor ? Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1) : Cesium.Color.BLACK, outlineWidth: 1, outline: this.style.outline } }); return e.objId = this.objId, e } getPositions(t) { let e = []; return e = t ? cUtil.cartesiansToLnglats([this.leftup, this.rightdown]) : [this.leftup, this.rightdown] } getStyle() { let t = {}, e = this.entity.rectangle; var i = e.material.color.getValue(), i = (t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), e.outline && (t.outline = e.outline.getValue()), t.outlineWidth = e.outlineWidth._value, e.outlineColor.getValue()); return t.outlineColorAlpha = i.alpha, t.outlineColor = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), e.fill && (t.fill = e.fill.getValue()), t.heightReference = e.heightReference.getValue(), t } setStyle(i) { if (i) { let t = i.color instanceof Cesium.Color ? i.color : Cesium.Color.fromCssColorString(i.color || "#ffff00"), e = (i.colorAlpha && (t = t.withAlpha(i.colorAlpha)), this.entity.rectangle.material = t, this.entity.rectangle.outline = i.outline, this.entity.rectangle.outlineWidth = i.outlineWidth, i.outlineColor instanceof Cesium.Color ? i.outlineColor : Cesium.Color.fromCssColorString(i.outlineColor || "#000000")); i.outlineColorAlpha && (e = e.withAlpha(i.outlineColorAlpha)), this.entity.rectangle.outlineColor = e, this.entity.rectangle.heightReference = Number(i.heightReference), 0 == i.heightReference && (this.entity.rectangle.height = Number(i.height), this.updatePointHeight(i.height)), this.entity.rectangle.fill = Boolean(i.fill), this.style = Object.assign(this.style, i) } } } class CreatePolyline extends BasePlot { constructor(t, e) { super(t, e), super(t, e = e || {}), this.movePush = !1, this.type = "polyline", this.maxPointNum = e.maxPointNum || Number.MAX_VALUE } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let o = this; this.handler.setInputAction(function (e) { e = o.getCatesian3FromPX(e.position, o.viewer, [o.entity]); if (e) { o.movePush && (o.positions.pop(), o.movePush = !1), o.positions.push(e); let t = o.createPoint(e); t.wz = o.positions.length - 1, o.controlPoints.push(t), o.positions.length == o.maxPointNum && (o.state = "endCreate", o.handler && (o.handler.destroy(), o.handler = null), o.prompt && (o.prompt.destroy(), o.prompt = null), o.viewer.trackedEntity = void 0, o.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), i && i(o.entity)) } }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { o.state = "creating", o.positions.length < 1 ? (o.prompt.update(t.endPosition, "单击开始绘制"), o.state = "startCreate") : (o.prompt.update(t.endPosition, "右键取消上一步，双击结束"), (t = o.getCatesian3FromPX(t.endPosition, o.viewer, [o.entity])) && (o.movePush ? o.positions[o.positions.length - 1] = t : (o.positions.push(t), o.movePush = !0), 2 != o.positions.length || Cesium.defined(o.entity) || (o.entity = o.createPolyline()))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { o.entity && (o.positions.splice(o.positions.length - 2, 1), o.viewer.entities.remove(o.controlPoints.pop()), 1 == o.positions.length && (o.entity && (o.viewer.entities.remove(o.entity), o.entity = null), o.prompt.update(t.endPosition, "单击开始绘制"), o.movePush = !1, o.positions = [])) }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.handler.setInputAction(function (t) { o.entity && (o.state = "endCreate", o.handler && (o.handler.destroy(), o.handler = null), o.positions.pop(), o.viewer.entities.remove(o.controlPoints.pop()), o.prompt && (o.prompt.destroy(), o.prompt = null), o.viewer.trackedEntity = void 0, o.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), i && i(o.entity)) }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } createByPositions(t, e) { if (t && !(t.length < 1)) { this.state = "startCreate"; var o = t[0] instanceof Cesium.Cartesian3 ? t : cUtil.lnglatsToCartesians(t); if (o) { this.entity = this.createPolyline(this.style), this.positions = o, e && e(this.entity); for (let i = 0; i < o.length; i++) { let e = o[i]; if (this.style.clampToGround) { let t = Cesium.Cartographic.fromCartesian(o[i]); t.height = this.viewer.scene.sampleHeight(t), e = Cesium.Cartographic.toCartesian(t) } let t = this.createPoint(e); t.wz = this.controlPoints.length, this.controlPoints.push(t) } this.state = "endCreate" } } } setStyle(i) { if (i) { let e = void 0; if (i.lineType) e = this.getMaterial(i.lineType, i); else { let t = i.color instanceof Cesium.Color ? i.color : Cesium.Color.fromCssColorString(i.color || "#000000"); e = t.withAlpha(i.colorAlpha || 1) } this.entity.polyline.material = e, this.entity.polyline.clampToGround = Number(i.clampToGround), i.width && (this.entity.polyline.width = i.width || 3), this.style = Object.assign(this.style, i) } } getStyle() { if (this.entity) { let t = {}, e = this.entity.polyline; null != this.style.lineType && (t.lineType = this.style.lineType, t.image = this.style.image, t.duration = this.style.duration), e.material instanceof Cesium.ColorMaterialProperty ? t.material = "common" : (e.material instanceof FlowLineMaterial && (t.material = "flowLine"), e.material instanceof FlyLineMaterial && (t.material = "flyLine"), t.duration = e.material.duration); var i = e.material.color.getValue(); return t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), t.width = e.width._value, t.clampToGround = !!e.clampToGround && e.clampToGround.getValue(), t } } createPolyline() { let t = this, e = this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return t.positions }, !1), show: !0, material: this.getMaterial(this.style.lineType, this.style), width: this.style.width || 3, clampToGround: this.style.clampToGround } }); return e.objId = this.objId, e } getMaterial(t, e) { e = e || {}; let i = null; return i = "flowLine" == t ? new FlowLineMaterial({ color: e.color || Cesium.Color.RED, image: e.image || "../img/texture/lineClr.png", duration: e.duration || 5e3 }) : "rainbowLine" == t ? new FlowLineMaterial({ image: e.image || "../img/texture/lineClr2.png", duration: e.duration || 5e3 }) : "flyLine" == t ? new FlyLineMaterial({ color: e.color || Cesium.Color.RED, duration: e.duration || 3e3, image: e.image || "../img/texture/glow.png", repeat: new Cesium.Cartesian2(1, 1) }) : e.color instanceof Cesium.Color ? e.color : e.color ? Cesium.Color.fromCssColorString(e.color).withAlpha(e.colorAlpha || 1) : Cesium.Color.WHITE } } class ArrowUtil { constructor(t) { this.FITTING_COUNT = 100, this.HALF_PI = Math.PI / 2, this.ZERO_TOLERANCE = 1e-4, this.TWO_PI = 2 * Math.PI, this.headHeightFactor = t.headHeightFactor, this.headWidthFactor = t.headWidthFactor, this.neckHeightFactor = t.neckHeightFactor, this.neckWidthFactor = t.neckWidthFactor, this.headTailFactor = t.headTailFactor, this.tailWidthFactor = t.tailWidthFactor, this.swallowTailFactor = t.swallowTailFactor } cartesian32WeMercator(t) { if (t) return t = this.cartesianToLnglat(t), this.lnglat2WeMercator(t) } webMercator2Cartesian3(t) { if (t) return t = this.webMercator2Lnglat(t), Cesium.Cartesian3.fromDegrees(t[0], t[1]) } webMercator2Lnglat(t) { var e; if (t) return e = t[0] / 20037508.34 * 180, t = t[1] / 20037508.34 * 180, [e, t = 180 / Math.PI * (2 * Math.atan(Math.exp(t * Math.PI / 180)) - Math.PI / 2)] } lnglat2WeMercator(t) { if (t) return [20037508.34 * t[0] / 180, 20037508.34 * (Math.log(Math.tan((90 + t[1]) * Math.PI / 360)) / (Math.PI / 180)) / 180] } getThirdPoint(t, e, i, o, s) { t = this.getAzimuth(t, e), s = s ? t + i : t - i, t = o * Math.cos(s), i = o * Math.sin(s); return [e[0] + t, e[1] + i] } getAzimuth(t, e) { var i = void 0, o = Math.asin(Math.abs(e[1] - t[1]) / this.MathDistance(t, e)); return e[1] >= t[1] && e[0] >= t[0] ? i = o + Math.PI : e[1] >= t[1] && e[0] < t[0] ? i = 2 * Math.PI - o : e[1] < t[1] && e[0] < t[0] ? i = o : e[1] < t[1] && e[0] >= t[0] && (i = Math.PI - o), i } MathDistance(t, e) { var i = Math.pow(t[0] - e[0], 2), t = Math.pow(t[1] - e[1], 2); return Math.sqrt(i + t) || .001 } isClockWise(t, e, i) { return (i[1] - t[1]) * (e[0] - t[0]) > (e[1] - t[1]) * (i[0] - t[0]) } getBisectorNormals(t, e, i, o) { var s = this.getNormal(e, i, o), n = null, r = null, a = null, l = Math.sqrt(s[0] * s[0] + s[1] * s[1]), h = s[0] / l, s = s[1] / l, c = this.MathDistance(e, i), d = this.MathDistance(i, o), r = l > this.ZERO_TOLERANCE ? this.isClockWise(e, i, o) ? (n = [i[0] - (a = t * c) * s, i[1] + a * h], [i[0] + (a = t * d) * s, i[1] - a * h]) : (n = [i[0] + (a = t * c) * s, i[1] - a * h], [i[0] - (a = t * d) * s, i[1] + a * h]) : (n = [i[0] + t * (e[0] - i[0]), i[1] + t * (e[1] - i[1])], [i[0] + t * (o[0] - i[0]), i[1] + t * (o[1] - i[1])]); return [n, r] } getCubicValue(t, e, i, o, s) { var n = 1 - (t = Math.max(Math.min(t, 1), 0)), r = t * t, a = r * t, l = n * n, h = l * n; return [h * e[0] + 3 * l * t * i[0] + 3 * n * r * o[0] + a * s[0], h * e[1] + 3 * l * t * i[1] + 3 * n * r * o[1] + a * s[1]] } getNormal(t, e, i) { var o = t[0] - e[0], t = t[1] - e[1], s = Math.sqrt(o * o + t * t), s = (o /= s, t /= s, i[0] - e[0]), i = i[1] - e[1], e = Math.sqrt(s * s + i * i); return [o + (s /= e), t + (i /= e)] } getArcPoints(t, e, i, o) { for (var s = [], n = (n = o - i) < 0 ? n + 2 * Math.PI : n, r = 0; r <= 100; r++) { var a = i + n * r / 100, l = t[0] + e * Math.cos(a), a = t[1] + e * Math.sin(a); s.push([l, a]) } return s } getBaseLength(t) { return Math.pow(this.wholeDistance(t), .99) } wholeDistance(i) { var o = 0, s = this; return i && Array.isArray(i) && 0 < i.length && i.forEach(function (t, e) { e < i.length - 1 && (o += s.MathDistance(t, i[e + 1])) }), o } getArrowHeadPoints(t, e, i) { this.DGIndex = t.length, this.points = t; var o = this.getBaseLength(t) * this.headHeightFactor, s = t[t.length - 1], n = this.MathDistance(s, t[t.length - 2]), e = this.MathDistance(e, i), i = (o = o > e * this.headTailFactor ? e * this.headTailFactor : o) * this.headWidthFactor, e = o * this.neckWidthFactor, n = (o = n < o ? n : o) * this.neckHeightFactor, o = this.getThirdPoint(t[t.length - 2], s, 0, o, !0), t = this.getThirdPoint(t[t.length - 2], s, 0, n, !0), n = this.getThirdPoint(s, o, Math.PI / 2, i, !1), o = this.getThirdPoint(s, o, Math.PI / 2, i, !0); return [this.getThirdPoint(s, t, Math.PI / 2, e, !1), n, s, o, this.getThirdPoint(s, t, Math.PI / 2, e, !0)] } getArrowHeadPointsNoLR(t) { var e = this.getBaseLength(t) * this.headHeightFactor, i = t[t.length - 1], o = e * this.headWidthFactor, s = e * this.neckWidthFactor, n = e * this.neckHeightFactor, e = this.getThirdPoint(t[t.length - 2], i, 0, e, !0), t = this.getThirdPoint(t[t.length - 2], i, 0, n, !0), n = this.getThirdPoint(i, e, Math.PI / 2, o, !1), e = this.getThirdPoint(i, e, Math.PI / 2, o, !0); return [this.getThirdPoint(i, t, Math.PI / 2, s, !1), n, i, e, this.getThirdPoint(i, t, Math.PI / 2, s, !0)] } getTailPoints(t) { var e = this.getBaseLength(t) * this.tailWidthFactor; return [this.getThirdPoint(t[1], t[0], Math.PI / 2, e, !1), this.getThirdPoint(t[1], t[0], Math.PI / 2, e, !0)] } getArrowBodyPoints(t, e, i, o) { for (var s = this.wholeDistance(t), n = this.getBaseLength(t) * o, r = (n - this.MathDistance(e, i)) / 2, a = 0, l = [], h = [], c = 1; c < t.length - 1; c++) { var d = this.getAngleOfThreePoints(t[c - 1], t[c], t[c + 1]) / 2, u = (n / 2 - (a += this.MathDistance(t[c - 1], t[c])) / s * r) / Math.sin(d), p = this.getThirdPoint(t[c - 1], t[c], Math.PI - d, u, !0), d = this.getThirdPoint(t[c - 1], t[c], d, u, !1); l.push(p), h.push(d) } return l.concat(h) } getAngleOfThreePoints(t, e, i) { t = this.getAzimuth(e, t) - this.getAzimuth(e, i); return t < 0 ? t + 2 * Math.PI : t } getQBSplinePoints(t) { if (t.length <= 2) return t; var e = [], i = t.length - 2 - 1; e.push(t[0]); for (var o = 0; o <= i; o++)for (var s = 0; s <= 1; s += .05) { for (var n = 0, r = 0, a = 0; a <= 2; a++) { var l = this.getQuadricBSplineFactor(a, s); n += l * t[o + a][0], r += l * t[o + a][1] } e.push([n, r]) } return e.push(t[t.length - 1]), e } getQuadricBSplineFactor(t, e) { var i = 0; return 0 === t ? i = Math.pow(e - 1, 2) / 2 : 1 === t ? i = (-2 * Math.pow(e, 2) + 2 * e + 1) / 2 : 2 === t && (i = Math.pow(e, 2) / 2), i } Mid(t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] } getCircleCenterOfThreePoints(t, e, i) { var o = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], e = [o[0] - t[1] + e[1], o[1] + t[0] - e[0]], s = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], t = [s[0] - t[1] + i[1], s[1] + t[0] - i[0]]; return this.getIntersectPoint(o, e, s, t) } getIntersectPoint(t, e, i, o) { return t[1] === e[1] ? [(o[0] - i[0]) / (o[1] - i[1]) * (t[1] - i[1]) + i[0], t[1]] : i[1] === o[1] ? [(e[0] - t[0]) / (e[1] - t[1]) * (i[1] - t[1]) + t[0], i[1]] : (e = (e[0] - t[0]) / (e[1] - t[1]), o = (o[0] - i[0]) / (o[1] - i[1]), [e * (i = (e * t[1] - t[0] - o * i[1] + i[0]) / (e - o)) - e * t[1] + t[0], i]) } getBezierPoints(t) { if (t.length <= 2) return t; for (var e = [], i = t.length - 1, o = 0; o <= 1; o += .01) { for (var s = 0, n = 0, r = 0; r <= i; r++) { var a = this.getBinomialFactor(i, r), l = Math.pow(o, r), h = Math.pow(1 - o, i - r); s += a * l * h * t[r][0], n += a * l * h * t[r][1] } e.push([s, n]) } return e.push(t[i]), e } getFactorial(t) { var e = 1; switch (t) { case t <= 1: e = 1; break; case 2 === t: e = 2; break; case 3 === t: e = 6; break; case 24 === t: e = 24; break; case 5 === t: e = 120; break; default: for (var i = 1; i <= t; i++)e *= i }return e } getBinomialFactor(t, e) { return this.getFactorial(t) / (this.getFactorial(e) * this.getFactorial(t - e)) } cartesianToLnglat(t) { var e; if (t) return viewer.scene.globe.ellipsoid, t = Cesium.Cartographic.fromCartesian(t), e = Cesium.Math.toDegrees(t.latitude), [Cesium.Math.toDegrees(t.longitude), e, t.height] } getCurvePoints(t, e) { for (var i = null, o = null, s = [this.getLeftMostControlPoint(e, t)], n = [], r = 0; r < e.length - 2; r++)var a = [e[r], e[r + 1], e[r + 2]], i = a[0], o = a[1], a = this.getBisectorNormals(t, i, o, a[2]), s = s.concat(a); var l = this.getRightMostControlPoint(e, t); l && s.push(l); for (var h = 0; h < e.length - 1; h++) { i = e[h], o = e[h + 1], n.push(i); for (var c = 0; c < this.FITTING_COUNT; c++) { var d = this.getCubicValue(c / this.FITTING_COUNT, i, s[2 * h], s[2 * h + 1], o); n.push(d) } n.push(o) } return n } getCubicValue(t, e, i, o, s) { var n = 1 - (t = Math.max(Math.min(t, 1), 0)), r = t * t, a = r * t, l = n * n, h = l * n; return [h * e[0] + 3 * l * t * i[0] + 3 * n * r * o[0] + a * s[0], h * e[1] + 3 * l * t * i[1] + 3 * n * r * o[1] + a * s[1]] } getLeftMostControlPoint(t, e) { var i, o, s, n, t = [t[0], t[1], t[2], null, null], r = t[0], a = t[1], l = t[2], h = t[3], t = t[4], c = this.getBisectorNormals(0, r, a, l)[0], l = this.getNormal(r, a, l); return t = Math.sqrt(l[0] * l[0] + l[1] * l[1]) > this.ZERO_TOLERANCE ? (l = this.Mid(r, a), s = r[0] - l[0], i = r[1] - l[1], o = 2 / this.MathDistance(r, a), n = c[0] - l[0], c = c[1] - l[1], h = l[0] + ((i = -o * i) * i - (o = o * s) * o) * n + (s = 2 * i * o) * c, l[1] + s * n + (o * o - i * i) * c) : (h = r[0] + e * (a[0] - r[0]), r[1] + e * (a[1] - r[1])), [h, t] } getBisectorNormals(t, e, i, o) { var s = this.getNormal(e, i, o), n = null, r = null, a = null, l = Math.sqrt(s[0] * s[0] + s[1] * s[1]), h = s[0] / l, s = s[1] / l, c = this.MathDistance(e, i), d = this.MathDistance(i, o), r = l > this.ZERO_TOLERANCE ? this.isClockWise(e, i, o) ? (n = [i[0] - (a = t * c) * s, i[1] + a * h], [i[0] + (a = t * d) * s, i[1] - a * h]) : (n = [i[0] + (a = t * c) * s, i[1] - a * h], [i[0] - (a = t * d) * s, i[1] + a * h]) : (n = [i[0] + t * (e[0] - i[0]), i[1] + t * (e[1] - i[1])], [i[0] + t * (o[0] - i[0]), i[1] + t * (o[1] - i[1])]); return [n, r] } getRightMostControlPoint(t, e) { var i, o, s, n, r = t.length, a = t[r - 3], l = t[r - 2], t = t[r - 1], r = this.getBisectorNormals(0, a, l, t)[1], a = this.getNormal(a, l, t), h = null, c = null; return c = Math.sqrt(a[0] * a[0] + a[1] * a[1]) > this.ZERO_TOLERANCE ? (a = this.Mid(l, t), s = t[0] - a[0], i = t[1] - a[1], o = 2 / this.MathDistance(l, t), n = r[0] - a[0], r = r[1] - a[1], h = a[0] + ((i = -o * i) * i - (o = o * s) * o) * n + (s = 2 * i * o) * r, a[1] + s * n + (o * o - i * i) * r) : (h = t[0] + e * (l[0] - t[0]), t[1] + e * (l[1] - t[1])), [h, c] } } class AttackArrow { constructor(t) { this.type = "AttackArrow", (t = t || {}).headHeightFactor = t.headHeightFactor || .18, t.headWidthFactor = t.headWidthFactor || .3, t.neckHeightFactor = t.neckHeightFactor || .85, t.neckWidthFactor = t.neckWidthFactor || .15, t.headTailFactor = t.headTailFactor || .8, this.positions = null, this.plotUtil = new ArrowUtil(t) } startCompute(t) { if (t) { this.positions = t; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } var s = [e[0], e[1]], n = s[0], s = s[1]; this.plotUtil.isClockWise(e[0], e[1], e[2]) && (n = e[1], s = e[0]); var r = [this.plotUtil.Mid(n, s)].concat(e.slice(2)), a = this.plotUtil.getArrowHeadPoints(r, n, s); if (!a || 0 == a.length) return console.warn("计算面数据有误，不计算，返回传入坐标数组！"), t; for (var l = [a[0], a[4]], h = l[0], l = l[1], c = this.plotUtil.MathDistance(n, s) / this.plotUtil.getBaseLength(r), r = this.plotUtil.getArrowBodyPoints(r, h, l, c), c = r.length, n = [n].concat(r.slice(0, c / 2)), h = (n.push(h), [s].concat(r.slice(c / 2, c))), d = (h.push(l), n = this.plotUtil.getQBSplinePoints(n), h = this.plotUtil.getQBSplinePoints(h), n.concat(a, h.reverse())), u = [], p = 0; p < d.length; p++) { var m = this.plotUtil.webMercator2Cartesian3(d[p]); u.push(m) } return u } } } class AttackArrowPW { constructor(t) { var e = {}; e.headHeightFactor = (t = t || {}).headHeightFactor || .18, e.headWidthFactor = t.headWidthFactor || .3, e.neckHeightFactor = t.neckHeightFactor || .85, e.neckWidthFactor = t.neckWidthFactor || .15, e.tailWidthFactor = this.tailWidthFactor = t.tailWidthFactor || .1, this.positions = null, this.plotUtil = new ArrowUtil(e) } startCompute(t) { if (t) { this.positions = t; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s = this.plotUtil.getTailPoints(e), n = this.plotUtil.getArrowHeadPoints(e, s[0], s[1]), r = n[0], a = n[4], l = this.plotUtil.getArrowBodyPoints(e, r, a, this.tailWidthFactor), h = l.length, c = [s[0]].concat(l.slice(0, h / 2)), r = (c.push(r), [s[1]].concat(l.slice(h / 2, h))), d = (r.push(a), c = this.plotUtil.getQBSplinePoints(c), r = this.plotUtil.getQBSplinePoints(r), c.concat(n, r.reverse())), u = [], p = 0; p < d.length; p++) { var m = this.plotUtil.webMercator2Cartesian3(d[p]); u.push(m) } return u } } } class AttackArrowYW { constructor(t) { var e = {}; e.headHeightFactor = (t = t || {}).headHeightFactor || .18, e.headWidthFactor = t.headWidthFactor || .3, e.neckHeightFactor = t.neckHeightFactor || .85, e.neckWidthFactor = t.neckWidthFactor || .15, e.tailWidthFactor = this.tailWidthFactor = t.tailWidthFactor || .1, e.headTailFactor = t.headTailFactor || .8, e.swallowTailFactor = this.swallowTailFactor = t.swallowTailFactor || 1, this.positions = null, this.plotUtil = new ArrowUtil(e) } startCompute(t) { if (t) { this.positions = t; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } var s = [e[0], e[1]], n = s[0], s = s[1]; this.plotUtil.isClockWise(e[0], e[1], e[2]) && (n = e[1], s = e[0]); for (var r = [this.plotUtil.Mid(n, s)].concat(e.slice(2)), a = this.plotUtil.getArrowHeadPoints(r, n, s), l = [a[0], a[4]], h = l[0], l = l[1], c = this.plotUtil.MathDistance(n, s), d = this.plotUtil.getBaseLength(r), u = d * this.tailWidthFactor * this.swallowTailFactor, u = this.plotUtil.getThirdPoint(r[1], r[0], 0, u, !0), r = this.plotUtil.getArrowBodyPoints(r, h, l, c / d), c = r.length, d = [n].concat(r.slice(0, c / 2)), n = (d.push(h), [s].concat(r.slice(c / 2, c))), p = (n.push(l), d = this.plotUtil.getQBSplinePoints(d), n = this.plotUtil.getQBSplinePoints(n), d.concat(a, n.reverse(), [u, d[0]])), m = [], g = 0; g < p.length; g++) { var C = this.plotUtil.webMercator2Cartesian3(p[g]); m.push(C) } return m } } } class CloseCurve { constructor(t) { this.positions = null, this.plotUtil = new ArrowUtil({}) } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } e.push(e[0], e[1]); for (var s = [], n = [], i = 0; i < e.length - 2; i++)var r = this.plotUtil.getBisectorNormals(.3, e[i], e[i + 1], e[i + 2]), s = s.concat(r); var a = s.length; s = [s[a - 1]].concat(s.slice(0, a - 1)); for (var l = 0; l < e.length - 2; l++) { var h = e[l], c = e[l + 1]; n.push(h); for (var d = 0; d <= 100; d++) { var u = this.plotUtil.getCubicValue(d / 100, h, s[2 * l], s[2 * l + 1], c); n.push(u) } n.push(c) } for (var p = [], m = 0; m < n.length; m++) { var g = this.plotUtil.webMercator2Cartesian3(n[m]); p.push(g) } return p } } class Curve { constructor(t) { this.typeName = "Curve", this.plotUtil = new ArrowUtil({}), this.t = .3 } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } var s = []; if (e.length < 2) return !1; for (var s = 2 === e.length ? e : this.plotUtil.getCurvePoints(this.t, e), n = [], r = 0; r < s.length; r++) { var a = this.plotUtil.webMercator2Cartesian3(s[r]); n.push(a) } return n } } class CurveFlag { constructor(t) { this.typeName = "CurveFlag", this.plotUtil = new ArrowUtil({}) } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s, n, r, a, l, h, c, d, u, p, m, g = [], C = (1 < e.length && (p = e[0], m = [((u = e[e.length - 1])[0] - p[0]) / 4 + p[0], (u[1] - p[1]) / 8 + p[1]], s = [(p[0] + u[0]) / 2, p[1]], n = [3 * (u[0] - p[0]) / 4 + p[0], -(u[1] - p[1]) / 8 + p[1]], r = [u[0], p[1]], a = [u[0], (p[1] + u[1]) / 2], l = [3 * (u[0] - p[0]) / 4 + p[0], 3 * (u[1] - p[1]) / 8 + p[1]], h = [(p[0] + u[0]) / 2, (p[1] + u[1]) / 2], c = [(u[0] - p[0]) / 4 + p[0], 5 * (u[1] - p[1]) / 8 + p[1]], d = [p[0], (p[1] + u[1]) / 2], u = [p[0], u[1]], p = this.plotUtil.getBezierPoints([p, m, s, n, r]), m = this.plotUtil.getBezierPoints([a, l, h, c, d]), (g = p.concat(m)).push(u)), []), y = 0; y < g.length; y++) { var v = this.plotUtil.webMercator2Cartesian3(g[y]); C.push(v) } return C } } class DoubleArrow { constructor(t) { var e = {}; e.headHeightFactor = (t = t || {}).headHeightFactor || .25, e.headWidthFactor = t.headWidthFactor || .3, e.neckHeightFactor = t.neckHeightFactor || .85, e.neckWidthFactor = t.neckWidthFactor || .15, this.positions = null, this.plotUtil = new ArrowUtil(e) } startCompute(t) { if (t) { this.positions = t; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s = [e[0], e[1], e[2]], n = s[0], r = s[1], s = s[2], a = this.positions.length, a = 3 === a ? (c = this.getTempPoint4(n, r, s), this.plotUtil.Mid(n, r)) : 4 === a ? (c = e[3], this.plotUtil.Mid(n, r)) : (c = e[3], e[4]), l = void 0, h = void 0, h = this.plotUtil.isClockWise(n, r, s) ? (l = this.getArrowPoints(n, a, c, !1), this.getArrowPoints(a, r, s, !0)) : (l = this.getArrowPoints(r, a, s, !1), this.getArrowPoints(a, n, c, !0)), r = l.length, s = (r - 5) / 2, a = l.slice(0, s), n = l.slice(s, 5 + s), c = l.slice(5 + s, r), l = h.slice(0, s), d = h.slice(s, 5 + s), h = h.slice(5 + s, r), l = this.plotUtil.getBezierPoints(l), s = this.plotUtil.getBezierPoints(h.concat(a.slice(1))), c = this.plotUtil.getBezierPoints(c), u = l.concat(d, s, n, c), p = [], m = 0; m < u.length; m++) { var g = this.plotUtil.webMercator2Cartesian3(u[m]); p.push(g) } return p } } getTempPoint4(t, e, i) { var e = this.plotUtil.Mid(t, e), o = this.plotUtil.MathDistance(e, i), i = this.plotUtil.getAngleOfThreePoints(t, e, i), s = void 0, n = void 0, r = void 0; return i < Math.PI / 2 ? (s = o * Math.sin(i), n = o * Math.cos(i), r = this.plotUtil.getThirdPoint(t, e, Math.PI / 2, s, !1), this.plotUtil.getThirdPoint(e, r, Math.PI / 2, n, !0)) : i >= Math.PI / 2 && i < Math.PI ? (s = o * Math.sin(Math.PI - i), n = o * Math.cos(Math.PI - i), r = this.plotUtil.getThirdPoint(t, e, Math.PI / 2, s, !1), this.plotUtil.getThirdPoint(e, r, Math.PI / 2, n, !1)) : i >= Math.PI && i < 1.5 * Math.PI ? (s = o * Math.sin(i - Math.PI), n = o * Math.cos(i - Math.PI), r = this.plotUtil.getThirdPoint(t, e, Math.PI / 2, s, !0), this.plotUtil.getThirdPoint(e, r, Math.PI / 2, n, !0)) : (s = o * Math.sin(2 * Math.PI - i), n = o * Math.cos(2 * Math.PI - i), r = this.plotUtil.getThirdPoint(t, e, Math.PI / 2, s, !0), this.plotUtil.getThirdPoint(e, r, Math.PI / 2, n, !1)) } getArrowPoints(t, e, i, o) { var s = this.plotUtil.Mid(t, e), n = this.plotUtil.MathDistance(s, i), r = this.plotUtil.getThirdPoint(i, s, 0, .3 * n, !0), a = this.plotUtil.getThirdPoint(i, s, 0, .5 * n, !0), r = [s, this.plotUtil.getThirdPoint(s, r, Math.PI / 2, n / 5, o), this.plotUtil.getThirdPoint(s, a, Math.PI / 2, n / 4, o), i], s = this.plotUtil.getArrowHeadPointsNoLR(r); if (!(s && Array.isArray(s) && 0 < s.length)) throw new Error("插值出错"); var a = [s[0], s[4]], n = a[0], o = a[1], i = this.plotUtil.MathDistance(t, e) / this.plotUtil.getBaseLength(r) / 2, a = this.plotUtil.getArrowBodyPoints(r, n, o, i); if (a) return r = a.length, i = a.slice(0, r / 2), a = a.slice(r / 2, r), i.push(n), a.push(o), (i = i.reverse()).push(e), (a = a.reverse()).push(t), i.reverse().concat(s, a) } } class FineArrow { constructor(t) { var e = {}; e.headAngle = this.headAngle = (t = t || {}).headAngle || Math.PI / 8.5, e.neckAngle = this.neckAngle = t.neckAngle || Math.PI / 13, e.tailWidthFactor = this.tailWidthFactor = t.tailWidthFactor || .1, e.neckWidthFactor = this.neckWidthFactor = t.neckWidthFactor || .2, e.headWidthFactor = this.headWidthFactor = t.headWidthFactor || .25, e.neckHeightFactor = t.neckHeightFactor || .85, this.positions = null, this.plotUtil = new ArrowUtil(e) } startCompute(t) { if (t) { this.positions = t; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s = [e[0], e[1]], n = s[0], s = s[1], r = this.plotUtil.getBaseLength(e), a = r * this.tailWidthFactor, l = r * this.neckWidthFactor, r = r * this.headWidthFactor, h = this.plotUtil.getThirdPoint(s, n, Math.PI / 2, a, !0), a = this.plotUtil.getThirdPoint(s, n, Math.PI / 2, a, !1), c = this.plotUtil.getThirdPoint(n, s, this.headAngle, r, !1), r = this.plotUtil.getThirdPoint(n, s, this.headAngle, r, !0), d = [h, this.plotUtil.getThirdPoint(n, s, this.neckAngle, l, !1), c, s, r, this.plotUtil.getThirdPoint(n, s, this.neckAngle, l, !0), a], u = [], p = 0; p < d.length; p++) { var m = this.plotUtil.webMercator2Cartesian3(d[p]); u.push(m) } return u } } } class GatheringPlace { constructor(t) { t = t || {}, this.positions = null, this.plotUtil = new ArrowUtil(t) } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s = this.plotUtil.Mid(e[0], e[2]), n = (e.push(s, e[0], e[1]), []), r = void 0, a = void 0, l = [], i = 0; i < e.length - 2; i++)var r = e[i], a = e[i + 1], h = e[i + 2], h = this.plotUtil.getBisectorNormals(.4, r, a, h), n = n.concat(h); s = n.length; n = [n[s - 1]].concat(n.slice(0, s - 1)); for (var c = 0; c < e.length - 2; c++) { r = e[c], a = e[c + 1], l.push(r); for (var d = 0; d <= 100; d++) { var u = this.plotUtil.getCubicValue(d / 100, r, n[2 * c], n[2 * c + 1], a); l.push(u) } l.push(a) } for (var p = [], m = 0; m < l.length; m++) { var g = this.plotUtil.webMercator2Cartesian3(l[m]); p.push(g) } return p } } class LineStraightArrow { constructor(t) { this.typeName = "LineStraightArrow", this.plotUtil = new ArrowUtil({}), this.fixPointCount = 2, this.maxArrowLength = 3e6, this.arrowLengthScale = 5 } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } var s = []; try { if (e.length < 2) return !1; var n = [e[0], e[1]], r = n[0], a = n[1], l = (l = this.plotUtil.MathDistance(r, a) / this.arrowLengthScale) > this.maxArrowLength ? this.maxArrowLength : l, s = [r, a, this.plotUtil.getThirdPoint(r, a, Math.PI / 6, l, !1), a, this.plotUtil.getThirdPoint(r, a, Math.PI / 6, l, !0)] } catch (t) { console.log(t) } for (var h = [], c = 0; c < s.length; c++) { var d = this.plotUtil.webMercator2Cartesian3(s[c]); h.push(d) } return h } } class Lune { constructor(t) { t = t || {}, this.positions = null, this.plotUtil = new ArrowUtil(t) } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } var s = [e[0], e[1], e[2], void 0, void 0], n = s[0], r = s[1], a = s[2], l = s[3], s = s[4], h = this.plotUtil.getCircleCenterOfThreePoints(n, r, a), c = this.plotUtil.MathDistance(n, h), d = this.plotUtil.getAzimuth(n, h), u = this.plotUtil.getAzimuth(r, h), s = this.plotUtil.isClockWise(n, r, a) ? (l = u, d) : (l = d, u); (e = this.plotUtil.getArcPoints(h, c, l, s)).push(e[0]); for (var p = [], m = 0; m < e.length; m++) { var g = this.plotUtil.webMercator2Cartesian3(e[m]); p.push(g) } return p } } class RectFlag { constructor(t) { (t = t || {}).typeName = "RectFlag", this.plotUtil = new ArrowUtil(t) } startCompute(t) { for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s, n, r = [], a = (1 < e.length && (r = [s = e[0], [(n = e[e.length - 1])[0], s[1]], [n[0], (s[1] + n[1]) / 2], [s[0], (s[1] + n[1]) / 2], [s[0], n[1]]]), []), l = 0; l < r.length; l++) { var h = this.plotUtil.webMercator2Cartesian3(r[l]); a.push(h) } return a } } class Sector { constructor(t) { this.typeName = "Sector", this.plotUtil = new ArrowUtil({}) } startCompute(t) { if (t.length <= 2) return []; for (var e = [], i = 0; i < t.length; i++) { var o = this.plotUtil.cartesian32WeMercator(t[i]); e.push(o) } for (var s = [e[0], e[1], e[2]], n = s[0], r = s[1], s = s[2], a = this.plotUtil.MathDistance(r, n), r = this.plotUtil.getAzimuth(r, n), s = this.plotUtil.getAzimuth(s, n), l = this.plotUtil.getArcPoints(n, a, r, s), h = (l.push(n, l[0]), []), c = 0; c < l.length; c++) { var d = this.plotUtil.webMercator2Cartesian3(l[c]); h.push(d) } return h } } var arrowAlgorithm = { AttackArrow: AttackArrow, AttackArrowPW: AttackArrowPW, AttackArrowYW: AttackArrowYW, CloseCurve: CloseCurve, Curve: Curve, CurveFlag: CurveFlag, DoubleArrow: DoubleArrow, FineArrow: FineArrow, GatheringPlace: GatheringPlace, LineStraightArrow: LineStraightArrow, Lune: Lune, RectFlag: RectFlag, Sector: Sector }; class CreateArrow extends BasePlot { constructor(t, e, i) { super(t, i), this.type = "arrow", e ? (this.situationType = e, this.arrowObj = getSituationByType(e), this.arrowObj && (this.minPointNum = this.arrowObj.minPointNum, 1 == this.minPointNum ? console.warn("控制点有误！") : (this.maxPointNum = -1 == this.arrowObj.maxPointNum ? this.minPointNum : this.arrowObj.maxPointNum, this.arrowPlot = this.arrowObj.arrowPlot, this.arrowPlot ? (this.type = "arrow", this.viewer = t, this.entity = null, this.polyline = null, this.style = Object.assign({ outlineColor: "#000000", outlineWidth: 2 }, i || {}), this.outline = null) : console.warn("计算坐标类有误！")))) : console.log("缺少箭头类型") } start(e) { let i = this; !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate", this.handler.setInputAction(function (e) { e = i.getCatesian3FromPX(e.position, i.viewer); if (e && !(i.positions.length > i.maxPointNum)) { i.movePush && (i.positions.pop(), i.movePush = !1), i.positions.push(e); let t = i.createPoint(e); t.wz = i.controlPoints.length, i.controlPoints.push(t) } }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { i.positions.length < 1 ? (i.prompt.update(t.endPosition, "单击开始绘制"), i.state = "startCreate") : (i.positions.length >= i.maxPointNum ? i.prompt.update(t.endPosition, "双击结束") : i.prompt.update(t.endPosition, "单击新增，不少于" + i.minPointNum + "个点</br>双击结束"), i.state = "creating", (t = i.getCatesian3FromPX(t.endPosition, i.viewer)) && (i.movePush ? i.positions[i.positions.length - 1] = t : (i.positions.push(t), i.movePush = !0), 2 <= i.positions.length && !Cesium.defined(i.polyline) && (i.polyline = i.createPolyline()), i.positions.length >= i.minPointNum && (Cesium.defined(i.entity) || (i.entity = i.createPolygon(), i.entity.objId = i.objId, i.polyline.show = !1)))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { i.entity && i.getCatesian3FromPX(t.position, i.viewer, [i.entity]) && i.positions.length >= i.minPointNum && (i.movePush || (i.positions.pop(), i.movePush = !1, i.viewer.entities.remove(i.controlPoints[i.controlPoints.length - 1]), i.controlPoints.pop()), i.prompt && (i.prompt.destroy(), i.prompt = null), i.state = "endCreate", i.handler.destroy(), e && e(i.entity)) }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } createByPositions(t, e) { if (t) { this.state = "startCreate"; var o = t[0] instanceof Cesium.Cartesian3 ? t : cUtil.lnglatsToCartesians(t); if (o) { this.entity = this.createPolygon(), this.positions = o; for (let i = 0; i < o.length; i++) { let e = o[i]; if (this.style.heightReference) { let t = Cesium.Cartographic.fromCartesian(o[i]); t.height = this.viewer.scene.sampleHeight(t), e = Cesium.Cartographic.toCartesian(t) } let t = this.createPoint(e); t.ctgc = ctgc, t.wz = this.controlPoints.length, this.controlPoints.push(t) } this.state = "endCreate", this.entity.objId = this.objId, e && e(this.entity) } } } getStyle() { if (this.entity) { let t = {}, e = this.entity.polygon; var i = e.material.color.getValue(); return t.colorAlpha = i.alpha, t.color = new Cesium.Color(i.red, i.green, i.blue, 1).toCssHexString(), t.fill = !!e.fill && e.fill.getValue(), e.heightReference && (i = e.heightReference.getValue(), t.heightReference = Boolean(i)), t } } setStyle(e) { if (e) { null != e.heightReference && (this.entity.polygon.heightReference = Number(e.heightReference)); let t = e.color instanceof Cesium.Color ? e.color : Cesium.Color.fromCssColorString(e.color); var i = t.withAlpha(e.colorAlpha || 1); this.entity.polygon.material = i, null != e.fill && (this.entity.polygon.fill = e.fill), this.style = Object.assign(this.style, e) } } createPolygon() { let e = this, t = (this.style.color = this.style.color || Cesium.Color.WHITE, this.style.outlineColor = this.style.outlineColor || Cesium.Color.BLACK, { polygon: { hierarchy: new Cesium.CallbackProperty(function () { let t = e.arrowPlot.startCompute(e.positions); return null != e.arrowPlot.spliceWZ && t.splice(e.arrowPlot.spliceWZ - 1, 1), new Cesium.PolygonHierarchy(t) }, !1), heightReference: Number(this.style.heightReference), show: !0, fill: this.style.fill || !0, material: this.style.color instanceof Cesium.Color ? this.style.color : Cesium.Color.fromCssColorString(this.style.color).withAlpha(this.style.colorAlpha || 1) } }); return this.style.heightReference || (t.polygon.height = 0, t.polygon.perPositionHeight = !0), this.viewer.entities.add(t) } createPolyline() { let t = this; return this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return t.positions }, !1), clampToGround: Boolean(this.style.clampToGround), material: this.style.outlineColor instanceof Cesium.Color ? this.style.outlineColor : Cesium.Color.fromCssColorString(this.style.outlineColor).withAlpha(this.style.outlineColorAlpha || 1), width: this.style.outlineWidth || 1 } }) } destroy() { this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.entity && (this.viewer.entities.remove(this.entity), this.entity = null), this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.positions = [], this.style = null, this.modifyPoint && (this.viewer.entities.remove(this.modifyPoint), this.modifyPoint = null); for (let t = 0; t < this.controlPoints.length; t++) { var e = this.controlPoints[t]; this.viewer.entities.remove(e) } this.controlPoints = [], this.state = "no", this.prompt && this.prompt.destroy(), this.polyline && (this.polyline = null, this.viewer.entities.remove(this.polyline)), this.forbidDrawWorld(!1) } } function getSituationByType(s) { if ((s = Number(s), !isNaN(s)) && (s && "number" == typeof s)) { let t, e = -1, i = -1, o = { canPlay: !1, pointNum: 0, pointWZ: [] }; switch (o.canPlay = !1, s) { case 1: t = new arrowAlgorithm.AttackArrow, e = 3, i = 999, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 2: t = new arrowAlgorithm.AttackArrowPW, e = 3, i = 999, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 3: t = new arrowAlgorithm.AttackArrowYW, e = 3, i = 999, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 4: t = new arrowAlgorithm.CloseCurve, e = 3, i = 999, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 5: t = new arrowAlgorithm.DoubleArrow, e = 3, i = 5, o.canPlay = !0, o.pointNum = 2, o.pointWZ = [2, 3]; break; case 6: t = new arrowAlgorithm.FineArrow, e = 2, i = 2, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 7: t = new arrowAlgorithm.FineArrowYW, e = 2, i = 2, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 8: t = new arrowAlgorithm.GatheringPlace, e = 3, i = 3, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 9: t = new arrowAlgorithm.Lune, e = 3, o.canPlay = !0, i = 3, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 10: t = new arrowAlgorithm.StraightArrow, e = 2, i = 2, o.canPlay = !0, o.pointNum = 1, o.pointWZ = [i]; break; case 11: t = new arrowAlgorithm.RectFlag, e = 2, i = 2, t.hasLine = !0, t.lineWZ = [1, 4, 5], t.spliceWZ = [5], o.canPlay = !1; break; case 12: t = new arrowAlgorithm.Sector, e = 3, i = 3, o.canPlay = !1; break; case 13: t = new arrowAlgorithm.TrangleFlag, e = 2, i = 2, t.hasLine = !0, t.lineWZ = [1, 3, 4], t.spliceWZ = [4], o.canPlay = !1; break; case 14: t = new arrowAlgorithm.CurveFlag, e = 2, i = 2, t.hasLine = !0, t.lineWZ = [1, 202, 203], t.spliceWZ = [203], o.canPlay = !1; break; case 15: t = new arrowAlgorithm.Curve, e = 2, i = 999, t.onlyLine = !0, o.canPlay = !0; break; case 16: t = new arrowAlgorithm.LineStraightArrow, e = 2, i = 2, t.onlyLine = !0, o.canPlay = !0; break; default: console.warn("不存在该类型！") }return { arrowPlot: t, minPointNum: e, maxPointNum: i, playObj: o } } console.warn("输入态势标绘类型不对！") } class DrawTool { constructor(t, e) { t ? (e = e || {}, this.viewer = t, this.toolArr = [], this.handler = null, this.removeHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.nowEditObj = null, this.startEditFun = null, this.endEditFun = null, this.removeFun = null, this.deleteEntityObj = null, this.bindEdit(), this.bindRemove(), this.deletePrompt = null, this.canEdit = null == e.canEdit || e.canEdit, this.intoEdit = null, this.lastEntityObj = null, this.lastStartEntityObj = null) : console.warn("缺少必要参数！--viewer") } on(t, e) { "startEdit" == t ? this.startEditFun = e : "endEdit" == t ? this.endEditFun = e : "remove" == t ? this.removeFun = e : "endCreate" == t && (this.endCreateFun = e) } canEdit(t) { this.canEdit = t } start(o) { if (o && o.type) { o.id = o.id || Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)); let e = this, i = (this.intoEdit = null == o.intoEdit || o.intoEdit, this.endEdit(), this.lastStartEntityObj && "startCreate" == this.lastStartEntityObj.state && (this.lastStartEntityObj.destroy(), this.lastStartEntityObj = null), this.createByType(o)); if (i) return i.attr = o || {}, i.start(function (t) { e.toolArr.push(i), o.success && o.success(i, t), e.endCreateFun && e.endCreateFun(i, t), 0 == o.show && i.setVisible(!1), e.canEdit && e.intoEdit && (i.startEdit(), e.startEditFun && e.startEditFun(i, t), e.lastEntityObj = i) }), this.lastStartEntityObj = i } } end() { this.lastStartEntityObj && "startCreate" == this.lastStartEntityObj.state && (this.lastStartEntityObj.destroy(), this.lastStartEntityObj = null), this.endEdit() } cancel() { !this.lastStartEntityObj || "endCreate" == this.lastStartEntityObj.state && "endEdit" == this.lastStartEntityObj.state || (this.lastStartEntityObj.destroy(), this.lastStartEntityObj = null) } startEditOne(t) { this.canEdit && (this.lastEntityObj && (this.lastEntityObj.endEdit(), this.endEditFun && this.endEditFun(this.lastEntityObj, this.lastEntityObj.getEntity()), this.lastEntityObj = null), t && (t.startEdit(), this.startEditFun && this.startEditFun(t, t.getEntity()), this.lastEntityObj = t)) } updateOneStyle(t, e) { t && t.setStyle(e) } createByPositions(o) { if ((o = (o = o || {}) || {}).positions) { o.id = o.id || Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)); let e = this, i = this.createByType(o); if (i) return i.attr = o, this.intoEdit = null == o.intoEdit || o.intoEdit, i.createByPositions(o.positions, function (t) { e.toolArr.push(i), i.setStyle(o.style), o.success && o.success(i, t), e.endCreateFun && e.endCreateFun(i, t), 0 == o.show && i.setVisible(!1) }), i } } createByGeojson(t) { var o = t["features"]; for (let i = 0; i < o.length; i++) { var { properties: s, geometry: n } = o[i], r = s.plotType, a = n.type, l = n.coordinates; let t = [], e = ""; switch (a) { case "LineString": t = cUtil$1.lnglatsToCartesians(l), e = "polyline"; break; case "Polygon": t = cUtil$1.lnglatsToCartesians(l[0]), e = "polygon"; break; case "Point": t = cUtil$1.lnglatsToCartesians([l])[0], e = r }this.createByPositions({ type: e, positions: t, style: s.style }) } } toGeojson() { let o = { type: "FeatureCollection", features: [] }; if (0 == this.toolArr.length) return null; for (let i = 0; i < this.toolArr.length; i++) { let t = this.toolArr[i]; var s = t.getPositions(!0), n = t.getStyle(), r = this.transType(t.type); let e = { type: "Feature", properties: { plotType: t.type, style: n }, geometry: { type: r, coordinates: [] } }; switch (r) { case "Polygon": e.geometry.coordinates = [s]; break; case "Point": case "LineString": e.geometry.coordinates = s }e.properties = Object.assign(e.properties, t.properties), o.features.push(e) } return o } transType(t) { let e = ""; switch (t) { case "polyline": e = "LineString"; break; case "polygon": e = "Polygon"; break; case "point": case "gltfModel": case "label": case "Billboard": e = "Point"; break; default: e = t }return e } destroy() { for (let t = 0; t < this.toolArr.length; t++)this.toolArr[t].destroy(); this.toolArr = [], this.nowEditObj = null, this.handler && (this.handler.destroy(), this.handler = null), this.removeHandler && (this.removeHandler.destroy(), this.removeHandler = null) } removeOne(t) { t && this.removeById(t.objId) } removeAll() { for (let e = 0; e < this.toolArr.length; e++) { let t = this.toolArr[e]; t.destroy() } this.toolArr = [], this.nowEditObj = null } hasEntityObj(t) { return !!t && this.getEntityObjByObjId(t.objId) != {} } removeById(t) { let e = this.getEntityObjByObjId(t); this.toolArr.splice(e.index, 1), this.removeFun && this.removeFun(e.entityObj, e.entityObj.getEntity()), e.entityObj && e.entityObj.destroy() } zoomToById(t) { let e = this.getEntityObjByObjId(t); e.entityObj && e.entityObj.zoomTo() } getEntityObjByAttr(e, i) { let o = {}; if (i) for (let t = 0; t < this.toolArr.length; t++) { var s = this.toolArr[t]; if (s.attr[e] == i) { o.entityObj = s, o.index = t; break } } else for (let t = 0; t < this.toolArr.length; t++) { var n = this.toolArr[t]; if (n.attr.id == e) { o.entityObj = n, o.index = t; break } } return o } setVisible(t, e) { let i = this.getEntityObjByAttr("id", t); i.entityObj && i.entityObj.setVisible(e) } getEntityObjByObjId(i) { if (i) { let e = {}; for (let t = 0; t < this.toolArr.length; t++) { var o = this.toolArr[t]; if (o.objId == i) { e.entityObj = o, e.index = t; break } } return e } } bindEdit() { let i = this; this.handler || (this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)), this.handler.setInputAction(function (t) { if (i.canEdit) { var e = i.viewer.scene.pick(t.position); if (Cesium.defined(e) && e.id) { for (let t = 0; t < i.toolArr.length; t++)if (e.id.objId == i.toolArr[t].objId && ("startCreate" != i.toolArr[t].state || "creating" != i.toolArr[t].state || "endEdit" != i.toolArr[t].state)) { i.lastEntityObj && (i.lastEntityObj.endEdit(), i.endEditFun && i.endEditFun(i.lastEntityObj, i.lastEntityObj.getEntity()), i.lastEntityObj = null), i.toolArr[t].startEdit(), i.nowEditObj = i.toolArr[t], i.startEditFun && i.startEditFun(i.nowEditObj, e.id), i.lastEntityObj = i.toolArr[t]; break } } else i.lastEntityObj && (i.lastEntityObj.endEdit(), i.endEditFun && i.endEditFun(i.lastEntityObj, i.lastEntityObj.getEntity()), i.lastEntityObj = null) } }, Cesium.ScreenSpaceEventType.LEFT_CLICK) } closeEdit() { this.endEdit(), this.canEdit = !1 } openEdit() { this.canEdit = !0 } endEdit() { this.lastEntityObj && (this.lastEntityObj.endEdit(), this.endEditFun && this.endEditFun(this.lastEntityObj, this.lastEntityObj.getEntity()), this.lastEntityObj = null); for (let t = 0; t < this.toolArr.length; t++)this.toolArr[t].endEdit() } bindRemove() { let s = this; this.removeHandler.setInputAction(function (e) { if (s.canEdit) { s.deletePrompt && (s.deletePrompt.destroy(), s.deletePrompt = null); var i = s.viewer.scene.pick(e.position); if (Cesium.defined(i) && i.id) for (let t = 0; t < s.toolArr.length; t++)if (i.id.objId == s.toolArr[t].objId && ("endCreate" == s.toolArr[t].state || "startEdit" == s.toolArr[t].state || "endEdit" == s.toolArr[t].state)) { s.deleteEntityObj = { entityObj: s.toolArr[t], index: t }; { o = void 0; var o = e.position; s.deletePrompt && (s.deletePrompt.destroy(), s.deletePrompt = null), s.deletePrompt = new Prompt$1(viewer, { content: "<span id='deleteEntity' style='cursor: pointer;'>删除</span>", show: !0, offset: { x: 60, y: 60 } }); let t = document.getElementById("deleteEntity"); s.deletePrompt.update(o), t.addEventListener("click", function () { if (s.endEdit(), s.deletePrompt.destroy(), s.deleteEntityObj && s.deleteEntityObj != {}) { let t = s.deleteEntityObj.entityObj; s.removeFun && s.removeFun(t, t.getEntity()), t.destroy(), s.toolArr.splice(s.deleteEntityObj.index, 1) } }) } break } } }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.removeHandler.setInputAction(function (t) { s.deletePrompt && (s.deletePrompt.destroy(), s.deletePrompt = null) }, Cesium.ScreenSpaceEventType.LEFT_CLICK) } getAll() { return this.toolArr } createByType(t) { let e = void 0, i = ""; if ("polyline" == t.type && (e = new CreatePolyline(this.viewer, t.style), i = "折线_"), "polygon" == t.type && (e = new CreatePolygon(this.viewer, t.style), i = "面_"), "billboard" == t.type && (e = new CreateBillboard(this.viewer, t.style), i = "图标_"), "circle" == t.type && (e = new CreateCircle(this.viewer, t.style), i = "圆_"), "rectangle" == t.type && (e = new CreateRectangle(this.viewer, t.style), i = "矩形_"), "gltfModel" == t.type && (e = new CreateGltfModel(this.viewer, t.style), i = "模型_"), "point" == t.type && (e = new CreatePoint(this.viewer, t.style), i = "点_"), "label" == t.type && (e = new CreateLabel(this.viewer, t.style), i = "文字_"), "arrow" == t.type) { if (!t.arrowType) return void console.log("缺少军事标绘类型"); e = new CreateArrow(this.viewer, t.arrowType, t.style) } return e && (e.name = i + (new Date).getTime()), e } } class BaseLayer { constructor(t, e) { this.viewer = t, this.opt = e || {}, this.id = e.id || Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), e.url || "tdt" == e.type || "grid" == e.type ? (this.providerAttr = {}, this.opt.rectangle && (this.opt.rectangle = new Cesium.Rectangle(Cesium.Math.toRadians(this.opt.rectangle[0]), Cesium.Math.toRadians(this.opt.rectangle[1]), Cesium.Math.toRadians(this.opt.rectangle[2]), Cesium.Math.toRadians(this.opt.rectangle[3])), this.providerAttr.rectangle = this.opt.rectangle), this.opt.minimumLevel && (this.providerAttr.minimumLevel = this.opt.minimumLevel), this.opt.maximumLevel && (this.providerAttr.maximumLevel = this.opt.maximumLevel), this.providerAttr.url = e.url, "EPSG:3857" == this.opt.srs ? this.opt.tilingScheme = new Cesium.WebMercatorTilingScheme : "EPSG:4490" != this.opt.srs && "EPSG:4326" == this.opt.srs && (this.opt.tilingScheme = new Cesium.GeographicTilingScheme), this.providerAttr = Object.assign(this.opt, this.providerAttr), this._layer = null, this._provider = {}) : console.log("缺少服务地址！", e) } get layer() { return this._layer } load() { if (this._provider && this._provider != {}) { let t = { rectangle: this.opt.rectangle, alpha: this.opt.alpha || 1, show: null == this.opt.show || this.opt.show }; this.opt.minimumTerrainLevel && (t.minimumTerrainLevel = this.opt.minimumTerrainLevel), this.opt.maximumTerrainLevel && (t.maximumTerrainLevel = this.opt.maximumTerrainLevel), this._layer = new Cesium.ImageryLayer(this._provider, t), this.viewer.imageryLayers.add(this._layer, this.opt.zIndex), this._layer.attr = this.opt } } getLayer() { return this._layer } remove() { this._layer && this.viewer.imageryLayers.remove(this._layer) } show() { this._layer && (this._layer.show = !0, this._layer.attr.show = !0) } hide() { this._layer && (this._layer.show = !1, this._layer.attr.show = !1) } setVisible(t) { (t = null == t || t) ? this.show() : this.hide() } zoomTo() { this.opt.view ? cUtil$1.setCameraView(this.opt.view) : this.viewer.zoomTo(this._layer) } setAlpha(t) { this._layer && (this._layer.alpha = t = null == t ? 1 : t) } lowerLayer() { this._layer && this.viewer.imageryLayers.lower(this._layer) } lowerLayerToBottom() { this._layer && this.viewer.imageryLayers.lowerToBottom(this._layer) } raiseLayer() { this._layer && this.viewer.imageryLayers.raise(this._layer) } raiselayerToTop() { this._layer && this.viewer.imageryLayers.raiseToTop(this._layer) } } class ArcgiscacheLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "arcgiscache", Cesium.UrlTemplateImageryProvider.prototype.padLeft0 || (Cesium.UrlTemplateImageryProvider.prototype.padLeft0 = function (t, e) { for (var i = (t = String(t)).length; i < e;)t = "0" + t, i++; return t }); t = Object.assign(this.providerAttr, { customTags: { arc_x: function (t, e, i, o) { return t.padLeft0(e.toString(16), 8) }, arc_y: function (t, e, i, o) { return t.padLeft0(i.toString(16), 8) }, arc_z: function (t, e, i, o) { return t.padLeft0(o.toString(), 2) }, arc_z4490: function (t, e, i, o) { return t.padLeft0((o + 1).toString(), 2) }, arc_X: function (t, e, i, o) { return t.padLeft0(e.toString(16), 8).toUpperCase() }, arc_Y: function (t, e, i, o) { return t.padLeft0(i.toString(16), 8).toUpperCase() }, arc_Z: function (t, e, i, o) { return t.padLeft0(o.toString(), 2).toUpperCase() }, arc_Z4490: function (t, e, i, o) { return t.padLeft0((o + 1).toString(), 2).toUpperCase() } } }); this._provider = new Cesium.UrlTemplateImageryProvider(t) } } class MapserverLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "mapserver", this._provider = new Cesium.ArcGisMapServerImageryProvider(this.providerAttr) } } class GridLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "grid"; t = Cesium.Color.fromCssColorString(e.color || "#C0C0C0"); this.viewer.scene.globe.baseColor = Cesium.Color.GREY, this.providerAttr.cells = this.providerAttr.cells || 4, this.providerAttr.color = t, this._provider = new Cesium.GridImageryProvider(this.providerAttr) } } class GeojsonLayer extends BaseLayer {
    constructor(t, e) { super(t, e), this.type = "geojson", this.viewer = t, this.opt = e || {}; this.style = Object.assign({ point: { color: "#00FFFF", colorAlpha: 1, outlineWidth: 1, outlineColor: "#000000", outlineColorAlpha: 1, pixelSize: 20 }, polyline: { color: "#FFFF00", colorAlpha: 1, width: 3, clampToGround: 1 }, polygon: { heightReference: 1, fill: !0, color: "#00FFFF", colorAlpha: 1, outline: !0, outlineWidth: 1, outlineColor: "#FFFF00", outlineColorAlpha: 1 } }, e.style || {}), this.url = this.opt.url || "", -1 != this.url.indexOf("WFS") && (this.url = this.opt.url + `?service=WFS&version=1.0.0&request=GetFeature&typeName=${this.opt.typeName}&maxFeatures=50&outputFormat=application%2Fjson`), this._layer = new Cesium.CustomDataSource(this.opt.typeName || "geojson" + (new Date).getTime()), this._layer.attr = this.opt, this.viewer.dataSources.add(this._layer) } load(i) { let d = this, t = Cesium.Resource.fetchJson({ url: this.url }); t.then(t => { var e = t["features"]; for (let t = 0; t < e.length; t++) { var { geometry: s, properties: n } = e[t]; if (s) { var { type: s, coordinates: r } = s; let o = []; switch (s) { case "Point": var a = cUtil$1.lnglatToCartesian(r); let t = d.createPoint(a, d.style.point, n); t.properties = n, d.opt.popup && (t.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (t.tooltip = d.getContent(n, d.opt.tooltip)); break; case "MultiPoint": for (let e = 0; e < r.length; e++) { var l = cUtil$1.lnglatToCartesian(r[e]); let t = d.createPoint(l, d.style.point, n); t.properties = n, d.opt.popup && (t.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (t.tooltip = d.getContent(n, d.opt.tooltip)) } break; case "LineString": o = cUtil$1.lnglatsToCartesians(r); let e = d.createPolyline(o, d.style.polyline, n); e.properties = n, d.opt.popup && (e.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (e.tooltip = d.getContent(n, d.opt.tooltip)); break; case "MultiLineString": for (let e = 0; e < r.length; e++) { var h = cUtil$1.lnglatsToCartesians(r[e]); let t = d.createPolyline(h, d.style.polyline, n); t.show = null == d.opt.show || d.opt.show, t.properties = n, d.opt.popup && (t.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (t.tooltip = d.getContent(n, d.opt.tooltip)) } break; case "Polygon": o = cUtil$1.lnglatsToCartesians(r[0]); let i = d.createPolygon(o, d.style.polygon, n); i.show = null == d.opt.show || d.opt.show, i.properties = n, d.opt.popup && (i.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (i.tooltip = d.getContent(n, d.opt.tooltip)); break; case "MultiPolygon": for (let e = 0; e < r.length; e++) { var c = cUtil$1.lnglatsToCartesians(r[e][0]); let t = d.createPolygon(c, d.style.polygon, n); t.show = null == d.opt.show || d.opt.show, t.properties = n, d.opt.popup && (t.popup = d.getContent(n, d.opt.popup)), d.opt.tooltip && (t.tooltip = d.getContent(n, d.opt.tooltip)) } } } } i && i() }) } zoomTo() { this._layer && (this._layer.attr.view ? cUtil$1.setCameraView(opt.view) : this.viewer.zoomTo(this._layer.entities)) } remove() { this._layer && this.viewer.dataSources.remove(this._layer) } show() { this._layer && (this._layer.show = !0, this._layer.attr.show = !0) } hide() { this._layer && (this._layer.attr.show = !1, this._layer.show = !1) } getContent(e, i) {
        let o = ""; for (let t = 0; t < i.length; t++) {
            var { field: s, fieldName: n } = i[t], s = e[s]; o += `
                <tr>
                    <td>${n}：</td>
                    <td>${s}</td>
                </tr>
            `} return `
            <table>${o}</table>
        `} getStyleValue(key, value, conditions) { let styleValue = null; for (let ind = 0; ind < conditions.length; ind++)if ("true" == conditions[ind][0]) { styleValue = conditions[ind][1]; break } for (let i = 0; i < conditions.length; i++) { let condition = conditions[i], replaceStr = "${" + key + "}", str = condition[0].replace(replaceStr, '"' + value + '"'); if (console.log("eval===>", str, eval(str)), eval(str)) { styleValue = condition[1]; break } } return styleValue } setAlpha(s) { let t = this._layer.entities.values; t.forEach(function (t) { var e = t.style; let i = null, o = (i = (i = Cesium.Color.fromCssColorString(e.color)).withAlpha(s || 1), null); o = (o = Cesium.Color.fromCssColorString(e.outlineColor)).withAlpha(s || 1), t.point && (t.point.color = i, t.point.outlineColor = o), t.polygon && (t.polygon.material = i), t.polyline && (t.polyline.material = o) }) } createPoint(t, e, i) { let o = null, s = ((e = this.getNewStyle(e, i)).color = e.color || "#ffff00", e.colorAlpha = e.colorAlpha || 1, o = (o = Cesium.Color.fromCssColorString(e.color)).withAlpha(e.colorAlpha), null), n = (e.outlineColor = e.outlineColor || "#000000", e.outlineColorAlpha = e.outlineColorAlpha || 1, s = (s = Cesium.Color.fromCssColorString(e.outlineColor)).withAlpha(e.outlineColorAlpha), this._layer.entities.add({ position: t, point: { color: o, outlineColor: s, outlineWidth: e.outlineWidth || 1, pixelSize: e.pixelSize || 6, heightReference: 1 } })); return n.style = e, n } createPolygon(t, e, i) { let o = null, s = ((e = this.getNewStyle(e, i)).color = e.color || "#ffff00", e.colorAlpha = e.colorAlpha || 1, o = (o = Cesium.Color.fromCssColorString(e.color)).withAlpha(e.colorAlpha), null), n = (e.outlineColor = e.outlineColor || "#000000", e.outlineColorAlpha = e.outlineColorAlpha || 1, s = (s = Cesium.Color.fromCssColorString(e.outlineColor)).withAlpha(e.outlineColorAlpha), {}), r = (n.polygon = { hierarchy: new Cesium.PolygonHierarchy(t), heightReference: 1, material: o }, e.outline && (n.polyline = { positions: new Cesium.CallbackProperty(function () { return t }, !1), material: s, width: e.outlineWidth || 1, clampToGround: !0 }), this._layer.entities.add(n)); return r.style = e, r } createPolyline(t, e, i) { let o = null, s = ((e = this.getNewStyle(e, i)).color = e.color || "#ffff00", e.colorAlpha = e.colorAlpha || 1, o = (o = Cesium.Color.fromCssColorString(e.color)).withAlpha(e.colorAlpha), this._layer.entities.add({ polyline: { positions: t, material: o, width: e.width || 3, clampToGround: !0 } })); return s.style = e, s } getRandomColor() { for (var t = "#", e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"], i = 0; i < 6; i++)t += e[parseInt(16 * Math.random())]; return t } getNewStyle(t, e) { t = JSON.parse(JSON.stringify(t || {})); let i = {}; if (e) { for (var o in t) { var s, n, r; t[o].conditions && t[o].conditions instanceof Array ? (s = t[o].field, n = t[o].conditions, r = e[s], i[o] = this.getStyleValue(s + "", r, n)) : t[o] instanceof String ? i[o] = t[o] : "random" == t[o].conditions && ("color" == t[o].type && (i[o] = this.getRandomColor()), "number" == t[o].type && (i[o] = 100 * Math.random())) } t = Object.assign(t, i) } return t }
} class TDTLayer extends BaseLayer { constructor(o, t) { var s = ["313cd4b28ed520472e8b43de00b2de56", "83b36ded6b43b9bc81fbf617c40b83b5", "0ebd57f93a114d146a954da4ecae1e67", "6c99c7793f41fccc4bd595b03711913e", "56b81006f361f6406d0e940d2f89a39c"]; if (super(o, t), this.type = "tdt", this.opt = t || {}, this.opt.keys && 0 != this.opt.keys.length ? Array.isArray(this.opt.keys) ? (o = Math.random() * this.opt.key.length, o = Math.floor(o), this.key = s[o]) : this.key = this.opt.keys : (t = Math.random() * s.length, t = Math.floor(t), this.key = s[t]), this.opt.layerName) { let t = "", e = ""; o = "https://t{s}.tianditu.gov.cn/" + (e = 4326 == this.opt.crs ? (t = "c", this.opt.layerName + "_c") : (t = "w", this.opt.layerName + "_w")) + "/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=" + this.opt.layerName + "&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=" + this.key; let i = []; for (let t = 0; t <= 18; t++)i[t] = t.toString(); s = { url: o, layer: e, style: "default", format: "tiles", tileMatrixSetID: t, subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"], tileMatrixLabels: i, tilingScheme: new Cesium.WebMercatorTilingScheme }, s = Object.assign(this.providerAttr || {}, s); this._provider = new Cesium.WebMapTileServiceImageryProvider(s) } else console.log("缺少图层名称") } } class SingleImageLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "singleImage", this._provider = new Cesium.SingleTileImageryProvider(this.opt) } } class TMSLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "tmsLayer", this._provider = new Cesium.TileMapServiceImageryProvider(this.opt) } } class XYZLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "XYZLayer", this._provider = new Cesium.UrlTemplateImageryProvider(this.providerAttr) } get layer() { return this._layer } get provider() { return this._provider } } class TilesetLayer extends BaseLayer { constructor(t, e) { super(t, e), this.opt = e || {}, this.type = "3dtiles", this.opt.url || console.log("缺少服务地址！", e), this._layer = void 0 } get layer() { return this._layer } load(e) { let i = this, t = this.viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ maximumScreenSpaceError: this.opt.maximumScreenSpaceError || 1, url: this.opt.url, preferLeaves: !0 })); t.readyPromise.then(function (t) { i._layer = t, i._layer.layerConfig = i.opt, i._layer.initBoundingSphere = t.boundingSphere.clone(), i._layer.show = null == i.opt.show || i.opt.show, i.opt.center && i.setCenter(i.opt.center), i.opt.position && i.setPosition(i.opt.position), i.opt.flyTo && i.zoomTo(), i.opt.style && i.updateStyle(t, i.opt.style), e && e(t) }).otherwise(function (t) { }) } remove() { this._layer && this.viewer.scene.primitives.remove(this._layer) } show() { this._layer && (this._layer.show = !0, this._layer.layerConfig.show = !0) } hide() { this._layer && (this._layer.show = !1, this._layer.layerConfig.show = !1) } zoomTo() { this._layer && (this._layer.layerConfig.view ? cUtil.setCameraView(this._layer.layerConfig.view) : this.viewer.flyTo(this._layer, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(0), Cesium.Math.toRadians(-60), 5 * this._layer.boundingSphere.radius))) } setCenter(t) { var e = Cesium.Cartographic.fromCartesian(this._layer.initBoundingSphere.center), i = Cesium.Cartesian3.fromRadians(e.longitude, e.latitude, 0), o = t.x || Cesium.Math.toDegrees(e.longitude), e = t.y || Cesium.Math.toDegrees(e.latitude), o = Cesium.Cartesian3.fromDegrees(o, e, t.z || 0), e = Cesium.Cartesian3.subtract(o, i, new Cesium.Cartesian3); this._layer.modelMatrix = Cesium.Matrix4.fromTranslation(e) } setPosition(e) { if (e) { let t; t = e instanceof Cesium.Cartesian3 ? e.clone() : Cesium.Cartesian3.fromDegrees(e.x, e.y, e.z); e = Cesium.Transforms.eastNorthUpToFixedFrame(t); this._layer._root.transform = e } } updateStyle(t, e) { t && e && (t.style = new Cesium.Cesium3DTileStyle(e)) } setAlpha(t) { t = null == t ? 1 : t, this._layer.style = new Cesium.Cesium3DTileStyle({ color: "color('rgba(255,255,255," + t + ")')" }) } } class WMSLayer extends BaseLayer { constructor(t, e) { super(t, e), this.type = "wms", this.providerAttr.layers || console.log("当前服务缺少 layers 参数！", this.providerAttr), this._provider = new Cesium.WebMapServiceImageryProvider(this.providerAttr) } } class LayerTool { constructor(t) { this.viewer = t, this._layerObjs = [] } get layers() { return this._layerObjs } add(t) { let e = null; switch ((t = JSON.parse(JSON.stringify(t || {}))).type) { case "xyz": e = new XYZLayer(this.viewer, t); break; case "wfs": case "geojson": e = new GeojsonLayer(this.viewer, t); break; case "mapserver": e = new MapserverLayer(this.viewer, t); break; case "arcgiscache": e = new ArcgiscacheLayer(this.viewer, t); break; case "tdt": e = new TDTLayer(this.viewer, t); break; case "singleImage": e = new SingleImageLayer(this.viewer, t); break; case "tms": e = new TMSLayer(this.viewer, t); break; case "3dtiles": e = new TilesetLayer(this.viewer, t); break; case "wms": e = new WMSLayer(this.viewer, t); break; case "grid": e = new GridLayer(this.viewer, t) }if (e) return "3dtiles" == e.type || "geojson" == e.type ? e.load(function () { null != t.alpha && e.setAlpha(t.alpha), e.setVisible(t.show) }) : (e.load(), null != t.alpha && e.setAlpha(t.alpha), e.setVisible(t.show)), this._layerObjs.push(e), t.id = t.id || Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), t.alpha = null == t.alpha ? 1 : t.alpha, e.attr = t, e } getLayerObjById(i) { if (i) { let e = {}; for (let t = 0; t < this._layerObjs.length; t++)if (this._layerObjs[t].attr.id == i) { e = { layerObj: this._layerObjs[t], index: t }; break } return e } } getLayerObj(t) { var { key: e, value: i } = t; for (let t = 0; t < this._layerObjs.length; t++)if (this._layerObjs[t].attr[e] == i) { this._layerObjs[t], t; break } } removeLayerObj(t) { t && this.removeLayerObjById(t.id) } removeLayerObjById(e) { if (e) { let t = this.getLayerObjById(e); t && t.layerObj && (t.layerObj.remove(), this._layerObjs.splice(t.index, 1)) } } removeAll() { for (let t = 0; t < this._layerObjs.length; t++)this._layerObjs[t].remove(); this._layerObjs = [] } destroy() { this.removeAll(), this._layerObjs = [], delete this._layerObjs } hideById(e) { if (e) { let t = this.getLayerObjById(e); t && t.layerObj && (t.layerObj.hide(), t.layerObj.attr.show = !1) } } showById(e) { if (e) { let t = this.getLayerObjById(e); t && t.layerObj && (t.layerObj.show(), t.layerObj.attr.show = !0) } } setVisible(t, e) { t && (e ? this.showById(t) : this.hideById(t)) } zoomTo(e) { if (e) { let t = this.getLayerObjById(e) || {}; t && t.layerObj && t.layerObj.zoomTo() } } hideAll() { for (let t = 0; t < this._layerObjs.length; t++)this._layerObjs[t].hide() } getAllshow() { let e = []; for (let t = 0; t < this._layerObjs.length; t++)this._layerObjs[t].attr.show && e.push(this._layerObjs[t]); return e } getAllhide() { let e = []; for (let t = 0; t < this._layerObjs.length; t++)this._layerObjs[t].attr.show || e.push(this._layerObjs[t]); return e } getLayerObjByField(i, o) { if (i) { let e = []; for (let t = 0; t < this._layerObjs.length; t++)this._layerObjs[t].attr[i] == o && e.push(this._layerObjs[t]); return e } } lowerLayer(e) { if (e) { e instanceof String && (e = { key: "id", value: e }); let t = this.getLayerObj(e); t && t.layerObj && t.layerObj.lowerLayer() } } lowerLayerToBottom(e) { if (e) { e instanceof String && (e = { key: "id", value: e }); let t = this.getLayerObj(e); t && t.layerObj && t.layerObj.lowerLayerToBottom() } } raiseLayer() { if (opt) { opt instanceof String && (opt = { key: "id", value: opt }); let t = this.getLayerObj(opt); t && t.layerObj && t.layerObj.raiseLayer() } } raiselayerToTop() { if (opt) { opt instanceof String && (opt = { key: "id", value: opt }); let t = this.getLayerObj(opt); t && t.layerObj && t.layerObj.raiselayerToTop() } } } class PopupTooltipTool { constructor(t, e) { this.viewer = t, this.opt = e || {}, this.toolOpen = !0, this.popupHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.tooltipHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.lastTooltipPromptEnt = void 0, this.defaultVal = { type: 2, show: !0 } } autoBindPopup() { let o = this; this.popupHandler.setInputAction(function (i) { if (o.toolOpen) { var t = o.viewer.scene.pick(i.position); if (Cesium.defined(t)) { let e; if (t.primitive && (e = t.primitive), (e = t.id && t.id instanceof Cesium.Entity ? t.id : e).click && e.click(e), null != e.popup) { if (!e.popupPrompt) { let t = {}; "string" == typeof e.popup ? t.content = e.popup : t = Object.assign(t, e.popup), t.type = t.type || 2, e.popupPrompt = o.createPrompt(e, t, i.position), e.popupPrompt.ent = e } e.position || e.popupPrompt.update(i.position); let t; t = e.popup.constructor == String || (null == e.popup.show || e.popup.show), e.popupPrompt.setVisible(t) } } } }, Cesium.ScreenSpaceEventType.LEFT_CLICK) } autoBindTooltip() { let o = this; this.popupHandler.setInputAction(function (i) { if (o.toolOpen) { var t = o.viewer.scene.pick(i.endPosition); let e; if (t && t.primitive && (e = t.primitive), e = t && t.id && t.id instanceof Cesium.Entity ? t.id : e) { if (o.lastTooltipPromptEnt && o.lastTooltipPromptEnt.tooltipPrompt && e.id != o.lastTooltipPromptEnt.id && (o.lastTooltipPromptEnt.tooltipPrompt.destroy(), o.lastTooltipPromptEnt.tooltipPrompt = null), null != e.tooltip && "" != e.tooltip) { e.tooltipPrompt ? e.tooltipPrompt.update(i.endPosition) : e.tooltipPrompt = o.createPrompt(e, e.tooltip, i.endPosition); let t; t = e.tooltip.constructor == String || (null == e.tooltip.show || e.tooltip.show), e.tooltipPrompt.setVisible(t), o.lastTooltipPromptEnt = e } } else o.lastTooltipPromptEnt && o.lastTooltipPromptEnt.tooltipPrompt && (o.lastTooltipPromptEnt.tooltipPrompt.destroy(), o.lastTooltipPromptEnt.tooltipPrompt = null) } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } createPrompt(t, e, i) { let o, s = JSON.parse(JSON.stringify(this.defaultVal)); return o = t.billboard || t.point || t.model ? t.position.getValue(this.viewer.clock.currentTime) : i, t.tooltip && (this.defaultVal.closeBtn = !1), s.position = o, e.constructor == String ? s.content = e : s = Object.assign(s, e), new Prompt$1(this.viewer, s) } close() { this.toolOpen = !1 } open() { this.toolOpen = !0 } } class RightTool {
    constructor(t, e) {
        e = e || {}; this.opt = Object.assign({ lnglat: !0, cameraView: !0, depth: !0 }, e), t ? (this.viewer = t, this.mapContainer = this.viewer.container, this.rightClickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.randomId = (new Date).getTime() + "" + Math.ceil(1e4 * Math.random()), e = `
            <div class="easy3d-right-tool" id="easy3d-right-tool-${this.randomId}">
                <ul>
                </ul>
            </div>
        `, $(this.mapContainer).append(e), $(document).off("click").on("click", function () { $(".easy3d-right-tool").hide() }), $(".easy3d-right-tool").click(function (t) { t.stopPropagation() }), this.opt.lnglat && this.crateLnglatTool(), this.opt.cameraView && this.createCameraViewTool(), this.opt.depth && this.crateDepthTool(), this.bindHandler(), this._clickPX = null) : console.log("缺少viewer对象！")
    } crateLnglatTool() {
        let r = this; var t = `
          <li class="right-tool-lnglat" id="right-tool-lnglat-${this.randomId}">
            <span style="font-weight:bold;">当前坐标</span>
          </li>
        `; $(`#easy3d-right-tool-${this.randomId} ul`).append(t), $("#right-tool-lnglat-" + this.randomId).on("click", function () {
            if ($("#easy3d-right-tool-" + r.randomId).hide(), r._clickPX) {
                var i = r.viewer.scene.drillPick(r._clickPX); r.viewer.scene.render(); let t, e = !1; for (let t = 0; t < i.length; t++)if (i[t] && i[t].primitive && i[t].primitive instanceof Cesium.Cesium3DTileset) { e = !0; break } if (e) t = r.viewer.scene.pickPosition(r._clickPX); else { var o = r.viewer.camera.getPickRay(r._clickPX); if (!o) return null; t = r.viewer.scene.globe.pick(o, r.viewer.scene) } var o = Cesium.Cartographic.fromCartesian(t.clone()), s = Cesium.Math.toDegrees(o.longitude), n = Cesium.Math.toDegrees(o.latitude), o = o.height, s = `
                世界坐标：
                <div>${`[${Number(t.x)} , ${Number(t.y)} , ${Number(t.z)}]`}</div>
                经纬度：
                <div>${`[${Number(s).toFixed(6)} , ${Number(n).toFixed(6)} , ${Number(o).toFixed(2)}]`}</div>
            `; r.crerateResultHtml("该点坐标", s)
            }
        })
    } createCameraViewTool() {
        let s = this; var t = `
          <li class="right-tool-view" id="right-tool-view-${this.randomId}">
                <span>相机视角</span>
          </li>
      `; $(`#easy3d-right-tool-${this.randomId} ul`).append(t), $("#right-tool-view-" + this.randomId).on("click", function () {
            $("#easy3d-right-tool-" + s.randomId).hide(); var t = s.viewer.camera, e = t.position, i = t.heading, o = t.pitch, t = t.roll, e = Cesium.Cartographic.fromCartesian(e), e = `
                <div>{</div>              
                <ul style="margin-left:10px;">
                    <li>
                        <span>
                            "x" : ${Cesium.Math.toDegrees(e.longitude)},
                        </span>
                    </li>
                    <li>
                        <span>
                            "y" : ${Cesium.Math.toDegrees(e.latitude)},
                        </span>
                    </li>
                    <li>
                        <span>
                            "z" : ${e.height},
                        </span>
                    </li>
                    <li>
                        <span>
                            "heading" : ${Cesium.Math.toDegrees(i)},
                        </span>
                    </li>
                    <li>
                        <span>
                            "pitch" : ${Cesium.Math.toDegrees(o)},
                        </span>
                    </li>
                    <li>
                        <span>
                        "roll" : ${Cesium.Math.toDegrees(t)}
                        </span>
                    </li>
                </ul>
                <div>}</div> 
            `; s.crerateResultHtml("当前相机视角", e)
        })
    } crateDepthTool() {
        let e = this; var t = this.viewer.scene.globe.depthTestAgainstTerrain, t = `
          <li>
            <span class="right-tool-depth" id="right-tool-depth-${this.randomId}">
              ${t ? "深度检测（关）" : "深度检测（开）"}
            </span>
          </li>
      `; $(`#easy3d-right-tool-${this.randomId} ul`).append(t), $("#right-tool-depth-" + this.randomId).on("click", function () { $("#easy3d-right-tool-" + e.randomId).hide(); const t = $(this).text(); -1 != t.indexOf("开") ? ($(this).text("深度检测（关）"), e.viewer.scene.globe.depthTestAgainstTerrain = !0) : ($(this).text("深度检测（开）"), e.viewer.scene.globe.depthTestAgainstTerrain = !1) })
    } refreshDepthVal() { var t = this.viewer.scene.globe.depthTestAgainstTerrain ? "深度检测（关）" : "深度检测（开）"; $("#right-tool-depth-" + this.randomId).html(t) } bindHandler() { let o = this; this.rightClickHandler.setInputAction(function (t) { var e = o.viewer.scene.pick(t.position); let i; !e || !e.primitive || e.primitive instanceof Cesium.Cesium3DTileset || (i = e.primitive), (i = e && e.id && e.id instanceof Cesium.Entity ? e.id : i) || (o.refreshDepthVal(), e = t.position, o._clickPX = t.position, $("#easy3d-right-tool-" + o.randomId).css({ left: Number(e.x + 10) + "px", top: Number(e.y + 10) + "px", display: "block" })) }, Cesium.ScreenSpaceEventType.RIGHT_CLICK) } destroy() { this.rightClickHandler && (this.rightClickHandler.destroy(), this.rightClickHandler = null), $("easy3d-right-tool-" + this.randomId).remove() } crerateResultHtml(t, e) {
        const i = this; $("#easy3d-right-content-" + this.randomId).remove(), this.createShadow(); t = `
            <div class="easy3d-right-content" class="easy3d-right-content-${this.randomId}">
                <span class="right-content-close" id="right-content-close-${this.randomId}" alt="" title="点击关闭">x</span>
                <div class="right-content-result scrollbar">
                <div class="content-result-title" style="font-weight:bold;">${t}：</div>
                <div class="content-result-line"></div>
                <div class="content-result-info">${e}</div>
                </div>
            </div>
        `; $("body").append(t), $("#right-content-close-" + this.randomId).off("click").on("click", function () { $(this).parent().remove(), $("#easy3d-right-tool-shadow-" + i.randomId).remove() })
    } createShadow() {
        $("#easy3d-right-tool-shadow-" + this.randomId).remove(); var t = `
            <div class="easy3d-right-tool-shadow" id="easy3d-right-tool-shadow-${this.randomId}"></div>
        `; $("body").append(t), $("#easy3d-right-tool-shadow-" + this.randomId).show()
    }
} let turf = require("turf/turf.js"); class BaseMeasure { constructor(t, e) { e = e || {}, this.viewer = t, this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.state = null, this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.floatLable = null, this.unit = e.unit, this.controlPoints = [], this.pointStyle = {}, this.modifyPoint = null, this.promptStyle = e.prompt || { show: !0, offset: { x: 30, y: 30 } } } createLine(e, i) { if (e) { let t = this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return e }, !1), show: !0, material: Cesium.Color.YELLOW.withAlpha(.7), width: 3, clampToGround: i } }); return t.objId = this.objId, t } } forbidDrawWorld(t) { this.viewer.scene.screenSpaceCameraController.enableRotate = !t, this.viewer.scene.screenSpaceCameraController.enableTilt = !t, this.viewer.scene.screenSpaceCameraController.enableTranslate = !t, this.viewer.scene.screenSpaceCameraController.enableInputs = !t } createLabel(t, e) { if (t) return this.viewer.entities.add({ position: t, label: { text: e || "", font: "24px Helvetica", fillColor: Cesium.Color.SKYBLUE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, disableDepthTestDistance: Number.POSITIVE_INFINITY, style: Cesium.LabelStyle.FILL_AND_OUTLINE, pixelOffset: new Cesium.Cartesian2(0, -20) } }) } setUnit(t) { t && (this.unit = t) } getAzimuthtAndCenter(i, o) { if (o && !(o.length < 2)) { let t = o[0].clone(); i = i || Cesium.Transforms.eastNorthUpToFixedFrame(t.clone()); var i = Cesium.Matrix4.inverse(i, new Cesium.Matrix4), o = o[1].clone(), i = (t = Cesium.Matrix4.multiplyByPoint(i, t, new Cesium.Cartesian3), o = Cesium.Matrix4.multiplyByPoint(i, o, new Cesium.Cartesian3), Cesium.Cartesian3.subtract(o, t, new Cesium.Cartesian3)), i = Cesium.Cartesian3.normalize(i, new Cesium.Cartesian3), s = new Cesium.Cartesian3(0, 1, 0), s = Cesium.Cartesian3.dot(s, i), i = new Cesium.Cartesian3(1, 0, 0), i = Cesium.Cartesian3.dot(i, o), o = Math.acos(s); let e = Cesium.Math.toDegrees(o); return e = i < 0 ? 360 - e : e } } formateLength(e, i) { if (null != e) { let t = ""; return "km" == (i = i || "m") || "千米" == i ? t += (Number(e) / 1e3).toFixed(2) + "km" : "m" != i && "米" != i || (t += Number(e).toFixed(2) + "m"), t } } formateArea(e, i) { if (null != e) { let t = ""; return "km" == (i = i || "m") || "平方千米" == i ? t += (Number(e) / 1e6).toFixed(2) + "km²" : "m" != i && "平方米" != i || (t += Number(e).toFixed(2) + "m²"), t } } getCatesian3FromPX(t, e) { for (var i, o = e.scene.drillPick(t), s = (e.scene.render(), !1), n = 0; n < o.length; n++)if (o[n] && o[n].primitive && o[n].primitive instanceof Cesium.Cesium3DTileset) { s = !0; break } if (s) i = e.scene.pickPosition(t); else { t = e.camera.getPickRay(t); if (!t) return null; i = e.scene.globe.pick(t, e.scene) } return i } getGroundLength(t, r) { var a = this.viewer.scene.globe.ellipsoid, e = this.getLength(t[0], t[1]); if (this.viewer.terrainProvider.availability) { var i = Cesium.PolylinePipeline.generateArc({ positions: t, granularity: 1e-5 }); if (i) { for (var o = [], l = Cesium.Cartographic.fromCartesian(t[0]).height, s = 0; s < i.length; s += 3) { var n = Cesium.Cartesian3.unpack(i, s); o.push(a.cartesianToCartographic(n)) } Cesium.when(Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, o), function (t) { for (var e = 0, i = 0; i < t.length; i++) { var o = t[i]; o.height ? o.height += 10 : o.height = l } for (var s = a.cartographicArrayToCartesianArray(t), n = 0; n < s.length - 1; n++)e += Cesium.Cartesian3.distance(s[n], s[n + 1]); e && r(e) }) } } else console.log("缺少地形数据，或地形加载失败！"), r && r(e) } getSlope(r, a) { var t, l, e, i, h; r && (e = Cesium.Cartographic.fromCartesian(r), t = Cesium.Math.toDegrees(e.latitude), i = Cesium.Math.toDegrees(e.longitude), l = e.height, e = Cesium.Cartographic.fromDegrees(i, t + 1e-5), i = Cesium.Cartographic.fromDegrees(i + 1e-5, t), h = this, Cesium.when(Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, [e, i]), function (t) { for (var e = 0; e < t.length; e++) { var i = t[e]; i.height = i.height || l } var o = h.viewer.scene.globe.ellipsoid.cartographicArrayToCartesianArray(t), s = o[0], o = o[1], n = Cesium.Transforms.eastNorthUpToFixedFrame(r), n = Cesium.Matrix4.inverse(n, new Cesium.Matrix4), n = (r = Cesium.Matrix4.multiplyByPoint(n, r, new Cesium.Cartesian3), s = Cesium.Matrix4.multiplyByPoint(n, s, new Cesium.Cartesian3), o = Cesium.Matrix4.multiplyByPoint(n, o, new Cesium.Cartesian3), Cesium.Cartesian3.subtract(s, r, new Cesium.Cartesian3)), s = Cesium.Cartesian3.subtract(o, r, new Cesium.Cartesian3), o = Cesium.Cartesian3.cross(n, s, new Cesium.Cartesian3), o = Cesium.Cartesian3.normalize(o, new Cesium.Cartesian3), n = new Cesium.Cartesian3(0, 0, 1), s = Cesium.Cartesian3.dot(o, n), o = Math.acos(s), n = 90 < (n = Cesium.Math.toDegrees(o)) ? 180 - n : n; a && a(n) })) } getLength(t, e) { return t && e && Cesium.Cartesian3.distance(t, e) || 0 } getAreaAndCenter(t) { if (t && !(t.length < 1)) { for (var e, i, o = [], s = [], n = 0; n < t.length; n++) { var r = t[n], r = Cesium.Cartographic.fromCartesian(r); o.push([Cesium.Math.toDegrees(r.longitude), Cesium.Math.toDegrees(r.latitude)]), s.push(turf.point([Cesium.Math.toDegrees(r.longitude), Cesium.Math.toDegrees(r.latitude)])) } if (o.length) return o = o.concat([o[0]]), e = turf.polygon([o]), e = turf.area(e), i = turf.featureCollection(s), i = turf.center(i).geometry.coordinates, { area: e, center: Cesium.Cartesian3.fromDegrees(i[0], i[1]) } } } createPoint(i) { if (i) { this.pointStyle.color = this.pointStyle.color || Cesium.Color.CORNFLOWERBLUE, this.pointStyle.outlineColor = this.pointStyle.color || Cesium.Color.CORNFLOWERBLUE; let t = this.pointStyle.color instanceof Cesium.Color ? this.pointStyle.color : Cesium.Color.fromCssColorString(this.pointStyle.color), e = (t = t.withAlpha(this.pointStyle.colorAlpha || .8), this.pointStyle.outlineColor instanceof Cesium.Color ? this.pointStyle.outlineColor : Cesium.Color.fromCssColorString(this.pointStyle.outlineColor)); return e = e.withAlpha(this.pointStyle.outlineColorAlpha || .8), this.viewer.entities.add({ position: i, point: { pixelSize: this.pointStyle.property || 10, color: t, outlineWidth: this.pointStyle.outlineWidth || 0, outlineColor: e, disableDepthTestDistance: Number.POSITIVE_INFINITY }, show: !1 }) } } } class MeasureGroundDistance extends BaseMeasure { constructor(t, e) { super(t, e), this.unitType = "length", this.type = "groundDistance", this.style = (e = e || {}).style || {}, this.viewer = t, this.polyline = null, this.positions = [], this.labels = [], this.nowLabel = null, this.nextlabel = null, this.lastPosition = null, this.nextPosition = null, this.modifyPoint = null, this.lastCartesian = null, this.allDistance = 0, this.prompt, this.movePush = !1, this.floatDistance = -1 } start(t) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)); let s = this; this.state = "startCreate", this.handler.setInputAction(function (i) { s.state = "creating"; let o = s.getCatesian3FromPX(i.position, s.viewer); if (o) { s.movePush && (s.positions.pop(), s.movePush = !1), s.floatLable || (s.floatLable = s.createLabel(o, ""), s.floatLable.wz = 0, s.floatLable.show = !1); let t = s.createLabel(o, ""), e = (t.wz = s.positions.length, s.labels.push(t), s.createPoint(o.clone())); e.wz = s.positions.length, s.controlPoints.push(e), 0 == s.positions.length ? t.label.text = "起点" : (s.lastDistance = s.floatDistance, s.allDistance += s.floatDistance, i = s.formateLength(s.floatDistance), t.label.text = i, t.distance = s.floatDistance), s.positions.push(o.clone()), s.lastCartesian = o.clone() } }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { if (s.state = "creating", s.positions.length < 1) s.prompt.update(t.endPosition, "单击开始测量"); else { s.prompt.update(t.endPosition, "双击结束，右键取消上一步"); let e = s.getCatesian3FromPX(t.endPosition, s.viewer); e && (s.movePush ? s.positions[s.positions.length - 1] = e.clone() : (s.positions.push(e), s.movePush = !0), Cesium.defined(s.polyline) || (s.polyline = s.createLine(s.positions, !0)), s.lastCartesian && s.getGroundLength([e, s.lastCartesian], function (t) { s.floatLable.show = !0, s.floatLable.label.text = s.formateLength(t, s.unit), s.floatLable.position.setValue(e), s.floatLable.distance = t, s.floatDistance = t, s.fun && s.fun(t) })) } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { if (s.state = "creating", s.polyline && !(s.positions.length <= 2)) { s.positions.splice(s.positions.length - 2, 1), s.viewer.entities.remove(s.labels.pop()), s.viewer.entities.remove(s.controlPoints.pop()), s.allDistance = s.allDistance - s.lastDistance, 1 == s.positions.length && (s.polyline && (s.viewer.entities.remove(s.polyline), s.polyline = null), s.prompt.update(t.endPosition, "单击开始测量"), s.floatLable.show = !1, s.positions = []); let e = s.getCatesian3FromPX(t.position, s.viewer); e && s.getGroundLength([e, s.positions[s.positions.length - 2]], function (t) { s.floatLable.show = !0, s.floatLable.label.text = s.formateLength(t, s.unit), s.floatLable.distance = t, s.floatLable.position.setValue(e) }) } }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.handler.setInputAction(function (t) { var e; s.polyline && (s.floatLable.show = !1, s.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), s.viewer.trackedEntity = void 0, s.positions.pop(), s.viewer.entities.remove(s.labels.pop()), s.viewer.entities.remove(s.controlPoints.pop()), e = s.formateLength(s.allDistance, s.unit), s.labels[s.labels.length - 1].label.text = "总长：" + e, s.handler && (s.handler.destroy(), s.handler = null), s.prompt && (s.prompt.destroy(), s.prompt = null), s.state = "endCreate") }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } startEdit(e) { if ("endCrerate" != this.state && "endEdit" != this.state || this.polyline) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let s = this; for (let e = 0; e < s.controlPoints.length; e++) { let t = s.controlPoints[e]; t && (t.show = !0) } this.modifyHandler.setInputAction(function (t) { var e, i, t = s.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (t.id.objId || (s.modifyPoint = t.id), s.forbidDrawWorld(!0), e = (t = s.modifyPoint.wz) + 1, i = t - 1, s.nowLabel = s.labels[t], 0 <= i && (s.lastPosition = s.positions[i]), e <= s.positions.length - 1 && (s.nextPosition = s.positions[e], s.nextlabel = s.labels[e])) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (o) { if (!(s.positions.length < 1) && s.modifyPoint) { let t = s.getCatesian3FromPX(o.endPosition, s.viewer); if (t) { s.modifyPoint.position.setValue(t); o = s.modifyPoint.wz; s.positions[o] = t.clone(), s.state = "editing", s.nowLabel.position.setValue(t.clone()); let e = 0, i = 0; s.nowLabel && s.lastPosition && s.getGroundLength([t.clone(), s.lastPosition.clone()], function (t) { s.nowLabel.label.text = s.formateLength(t, s.unit), e = t - s.nowLabel.distance, s.nowLabel.distance = t, s.allDistance = s.allDistance + e + i; t = s.formateLength(s.allDistance, s.unit); s.labels[s.labels.length - 1].label.text = "总长：" + t }), s.nextPosition && s.nextlabel && s.getGroundLength([t.clone(), s.nextPosition.clone()], function (t) { s.nextlabel.label.text = s.formateLength(t, s.unit), i = t - s.nextlabel.distance, s.nextlabel.distance = t, s.allDistance = s.allDistance + e + i; t = s.formateLength(s.allDistance, s.unit); s.labels[s.labels.length - 1].label.text = "总长：" + t }) } } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { s.modifyPoint && (s.modifyPoint = null, s.lastPosition = null, s.nextPosition = null, s.forbidDrawWorld(!1), e && e(), s.state = "endEdit") }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit() { this.state = "endEdit", this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null); for (let e = 0; e < this.controlPoints.length; e++) { let t = this.controlPoints[e]; t && (t.show = !1) } } destroy() { this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null); for (let t = 0; t < this.labels.length; t++)this.viewer.entities.remove(this.labels[t]); this.labels = []; for (let t = 0; t < this.controlPoints.length; t++)this.viewer.entities.remove(this.controlPoints[t]); this.controlPoints = [], this.modifyPoint = null, this.floatLable && (this.viewer.entities.remove(this.floatLable), this.floatLable = null), this.floatLable = null, this.prompt && (this.prompt.destroy(), this.prompt = null), this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), this.viewer.trackedEntity = void 0, this.state = "no" } setUnit(i) { for (let e = 0; e < this.labels.length; e++) { let t = this.labels[e]; var o = t.distance; e == this.labels.length - 1 ? t.text = "总长：" + this.formateLength(o, i) : t.text = this.formateLength(o, i) } this.unit = i } } class MeasureSpaceDistance extends MeasureGroundDistance { constructor(t, e) { super(t, e), this.unitType = "length", this.type = "spaceDistance", this.allDistance = 0, this.labels = [], this.nowLabel = null, this.nextlabel = null, this.lastPosition = null, this.nextPosition = null } start(i) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)); let n = this; this.state = "startCreate", this.handler.setInputAction(function (i) { n.state = "creating"; let o = n.getCatesian3FromPX(i.position, n.viewer); if (o) { n.movePush && (n.positions.pop(), n.movePush = !1); let t; var s; 0 == n.positions.length ? (t = n.createLabel(o, "起点"), n.floatLable = n.createLabel(o, ""), n.floatLable.wz = 0, n.floatLable.show = !1) : (i = n.getLength(o, n.lastCartesian), n.lastDistance = i, n.allDistance += i, s = n.formateLength(i, n.unit), (t = n.createLabel(o, s)).wz = n.positions.length, t.distance = i), n.labels.push(t); let e = n.createPoint(o.clone()); e.wz = n.positions.length, n.controlPoints.push(e), n.positions.push(o), n.lastCartesian = o.clone() } }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { var e = n.getCatesian3FromPX(t.endPosition, n.viewer); e && (n.state = "creating", n.positions.length < 1 ? n.prompt.update(t.endPosition, "单击开始测量") : (n.prompt.update(t.endPosition, "双击结束，右键取消上一步"), n.floatLable.show = !0, n.movePush ? n.positions[n.positions.length - 1] = e : (n.positions.push(e), n.movePush = !0), Cesium.defined(n.polyline) || (n.polyline = n.createLine(n.positions, !1)), n.lastCartesian && (t = n.getLength(e, n.lastCartesian), n.floatLable.show = !0, n.floatLable.label.text = n.formateLength(t, n.unit), n.floatLable.distance = t, n.floatLable.position.setValue(e)))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { var e; n.state = "creating", !n.polyline || n.positions.length <= 2 || (n.positions.splice(n.positions.length - 2, 1), n.viewer.entities.remove(n.labels.pop()), n.viewer.entities.remove(n.controlPoints.pop()), n.allDistance = n.allDistance - n.lastDistance, 1 == n.positions.length && (n.polyline && (n.viewer.entities.remove(n.polyline), n.polyline = null), n.prompt.update(t.endPosition, "单击开始测量"), n.movePush = !1, n.floatLable.show = !1, n.positions = []), (t = n.getCatesian3FromPX(t.position, n.viewer)) && (e = n.getLength(t, n.positions[n.positions.length - 2]), n.floatLable.show = !0, n.floatLable.label.text = n.formateLength(e, n.unit), n.floatLable.distance = e, n.floatLable.position.setValue(t))) }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.handler.setInputAction(function (t) { var e; n.polyline && (n.floatLable.show = !1, n.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), n.viewer.trackedEntity = void 0, n.positions.pop(), n.viewer.entities.remove(n.labels.pop()), n.viewer.entities.remove(n.controlPoints.pop()), e = n.formateLength(n.allDistance, n.unit), n.labels[n.labels.length - 1].label.text = "总长：" + e, n.movePush = !1, n.prompt && (n.prompt.destroy(), n.prompt = null), n.handler && (n.handler.destroy(), n.handler = null), n.state = "endCreate", i && i()) }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } startEdit(e) { if ("endCrerate" != this.state && "endEdit" != this.state || this.polyline) { this.state = "startEdit", this.modifyHandler || (this.modifyHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)); let s = this; for (let e = 0; e < s.controlPoints.length; e++) { let t = s.controlPoints[e]; t && (t.show = !0) } this.modifyHandler.setInputAction(function (t) { var e, i, t = s.viewer.scene.pick(t.position); Cesium.defined(t) && t.id && (t.id.objId || (s.modifyPoint = t.id), s.forbidDrawWorld(!0), e = (t = s.modifyPoint.wz) + 1, i = t - 1, s.nowLabel = s.labels[t], 0 <= i && (s.lastPosition = s.positions[i]), e <= s.positions.length - 1 && (s.nextPosition = s.positions[e], s.nextlabel = s.labels[e])) }, Cesium.ScreenSpaceEventType.LEFT_DOWN), this.modifyHandler.setInputAction(function (o) { if (!(s.positions.length < 1) && s.modifyPoint) { let i = s.getCatesian3FromPX(o.endPosition, s.viewer); if (i) { s.modifyPoint.position.setValue(i); var o = s.modifyPoint.wz; s.positions[o] = i.clone(), s.state = "editing", s.nowLabel.position.setValue(i.clone()); let t = 0, e = (s.nowLabel && s.lastPosition && (o = s.getLength(i.clone(), s.lastPosition.clone()), s.nowLabel.label.text = s.formateLength(o, s.unit), t = o - s.nowLabel.distance, s.nowLabel.distance = o), 0); s.nextPosition && s.nextlabel && (o = s.getLength(i.clone(), s.nextPosition.clone()), s.nextlabel.label.text = s.formateLength(o, s.unit), e = o - s.nextlabel.distance, s.nextlabel.distance = o), s.allDistance = s.allDistance + t + e; o = s.formateLength(s.allDistance, s.unit); s.labels[s.labels.length - 1].label.text = "总长：" + o } } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.modifyHandler.setInputAction(function (t) { s.modifyPoint && (s.modifyPoint = null, s.lastPosition = null, s.nextPosition = null, s.forbidDrawWorld(!1), e && e(), s.state = "endEdit") }, Cesium.ScreenSpaceEventType.LEFT_UP) } } endEdit() { this.state = "endEdit", this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null); for (let e = 0; e < this.controlPoints.length; e++) { let t = this.controlPoints[e]; t && (t.show = !1) } } destroy() { this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null); for (let t = 0; t < this.labels.length; t++)this.viewer.entities.remove(this.labels[t]); this.labels = []; for (let t = 0; t < this.controlPoints.length; t++)this.viewer.entities.remove(this.controlPoints[t]); this.controlPoints = [], this.modifyPoint = null, this.floatLable && (this.viewer.entities.remove(this.floatLable), this.floatLable = null), this.floatLable = null, this.prompt && (this.prompt.destroy(), this.prompt = null), this.handler && (this.handler.destroy(), this.handler = null), this.modifyHandler && (this.modifyHandler.destroy(), this.modifyHandler = null), this.movePush = !1, this.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), this.viewer.trackedEntity = void 0, this.state = "no" } setUnit(i) { for (let e = 0; e < this.labels.length; e++) { let t = this.labels[e]; var o = t.distance; e == this.labels.length - 1 ? t.text = "总长：" + that.formateLength(o, i) : t.text = that.formateLength(o, i) } this.unit = i } } class MeasureSpaceArea extends BaseMeasure { constructor(t, e) { super(t, e), e = e || {}, this.unitType = "area", this.style = e.style || {}, this.viewer = t, this.polyline = null, this.polygon = null, this.positions = [], this.movePush = !1, this.prompt } start(s) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)); var n = this; this.state = "startCreate", this.handler.setInputAction(function (t) { n.state = "creating"; t = n.getCatesian3FromPX(t.position, n.viewer); t && (n.movePush && (n.positions.pop(), n.movePush = !1), n.positions.push(t)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { var e, i; n.state = "creating", n.positions.length < 1 ? n.prompt.update(t.endPosition, "单击开始绘制") : (n.prompt.update(t.endPosition, "双击结束，右键取消上一步"), t = n.getCatesian3FromPX(t.endPosition, n.viewer), 1 <= n.positions.length && (n.movePush ? n.positions[n.positions.length - 1] = t : (n.positions.push(t), n.movePush = !0), 2 != n.positions.length || Cesium.defined(n.polyline) || (n.polyline = n.createPolyline()), 3 == n.positions.length && (Cesium.defined(n.polygon) || (n.polygon = n.createPolygon(), n.polygon.isFilter = !0, n.polygon.objId = n.objId, n.polyline && (n.polyline.show = !1)), n.floatLabel || (n.floatLabel = n.createLabel(t, ""))), n.polygon && (e = (t = n.getAreaAndCenter(n.positions)).area, t = t.center, i = n.formateArea(e, n.unit), n.floatLabel.label.text = "面积：" + i, n.floatLabel.area = e, t && n.floatLabel.position.setValue(t), n.floatLabel.show = !0))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE), this.handler.setInputAction(function (t) { var e, i; n.state = "creating", (n.polyline || n.polygon) && (n.positions.splice(n.positions.length - 2, 1), 2 == n.positions.length && (n.polygon && (n.viewer.entities.remove(n.polygon), n.polygon = null, n.polyline && (n.polyline.show = !0)), n.floatLabel.show = !1), 1 == n.positions.length && (n.polyline && (n.viewer.entities.remove(n.polyline), n.polyline = null), n.prompt.update(t.endPosition, "单击开始测量"), n.positions = [], n.movePush = !1), 2 < n.positions.length && (e = (t = n.getAreaAndCenter(n.positions)).area, t = t.center, i = n.formateArea(e, n.unit), n.floatLabel.label.text = "面积：" + i, t && n.floatLabel.position.setValue(t), n.floatLabel.area = e, n.floatLabel.show = !0)) }, Cesium.ScreenSpaceEventType.RIGHT_CLICK), this.handler.setInputAction(function (t) { var e, i, o; n.polygon && (n.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), n.viewer.trackedEntity = void 0, n.positions.pop(), e = (i = n.getAreaAndCenter(n.positions)).area, i = i.center, o = n.formateArea(e, n.unit), n.floatLabel.label.text = "面积：" + o, n.floatLabel.area = e, i && n.floatLabel.position.setValue(i), n.handler && (n.handler.destroy(), n.handler = null), n.movePush = !1, n.prompt && (n.prompt.destroy(), n.prompt = null), n.state = "endCreate", s && s(n.polyline)) }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK) } destroy() { this.state = "no", this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.polygon && (this.viewer.entities.remove(this.polygon), this.polygon = null), this.floatLabel && (this.viewer.entities.remove(this.floatLabel), this.floatLabel = null), this.handler && (this.handler.destroy(), this.handler = null), this.floatLable = null } createPolyline() { var t = this; return this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return t.positions }, !1), material: Cesium.Color.YELLOW, width: 3, clampToGround: !0 } }) } createPolygon() { var t = this; return viewer.entities.add({ polygon: new Cesium.PolygonGraphics({ hierarchy: new Cesium.CallbackProperty(function () { return new Cesium.PolygonHierarchy(t.positions) }, !1), material: this.style.material || Cesium.Color.LIME.withAlpha(.5), fill: !0 }) }) } setUnit(t) { this.unit = t; t = this.formateArea(this.floatLabel.area, t); this.floatLabel.label.text = "面积：" + t } } class MeasureHeight extends BaseMeasure { constructor(t, e) { super(t, e), e = e || {}, this.unitType = "length", this.style = e.style || {}, this.viewer = t, this.polyline = null, this.floatLabel = null, this.positions = [], this.height = 0 } start() { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.state = "startCreate"; let i = this; this.handler.setInputAction(function (t) { i.state = "creating"; t = i.getCatesian3FromPX(t.position, i.viewer); t && (2 == i.positions.length && (i.positions.pop(), i.positions.push(t), i.handler && (i.handler.destroy(), i.handler = null), i.prompt && (i.prompt.destroy(), i.prompt = null), i.state = "endCreate"), i.positions.push(t)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { var e = i.getCatesian3FromPX(t.endPosition, i.viewer); e && (i.state = "creating", i.positions.length < 1 ? i.prompt.update(t.endPosition, "单击开始测量") : (i.prompt.update(t.endPosition, "单击结束"), 2 != i.positions.length || Cesium.defined(i.polyline) || (i.polyline = i.createLine(i.positions, !1), i.floatLabel || (i.floatLabel = i.createLabel(e, ""))), t = i.getHeightAndCenter(i.positions[0], i.positions[1]), e = i.formateLength(t.height, i.unit), i.height = t.height, i.floatLabel.label.text = "高度差：" + e, i.floatLabel.length = t.height, t.center && i.floatLabel.position.setValue(t.center))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.floatLabel && (this.viewer.entities.remove(this.floatLabel), this.floatLabel = null), this.prompt && (this.prompt.destroy(), this.prompt = null), this.handler && (this.handler.destroy(), this.handler = null), this.state = "no" } getHeightAndCenter(t, e) { var i, o; if (t && e) return i = Cesium.Cartographic.fromCartesian(t), o = Cesium.Cartographic.fromCartesian(e), { height: Math.abs(i.height - o.height), center: Cesium.Cartesian3.midpoint(t, e, new Cesium.Cartesian3) } } setUnit(t) { var e = this.formateLength(this.floatLabel.length, t); this.floatLabel.label.text = "高度差：" + e, this.unit = t } } class MeasureTriangle extends BaseMeasure { constructor(t, e) { super(t, e), e = e || {}, this.unitType = "length", this.style = e.style || {}, this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.viewer = t, this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.ts_handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.heightfloatLabel = null, this.spaceDistancefloatLabel = null, this.horizonDistancefloatLabel = null, this.heightLine = null, this.spaceLine = null, this.horizonLine = null, this.firstPoint = null, this.endPoint = null, this.midPoint = null, this.prompt } start() { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)); var i = this; this.state = 1, this.handler.setInputAction(function (t) { t = i.getCatesian3FromPX(t.position, i.viewer); t && (i.firstPoint ? (i.endPoint = t, i.midPoint = i.computerPoint(i.firstPoint, i.endPoint), i.handler && (i.handler.destroy(), i.handler = null), i.ts_handler && (i.ts_handler.destroy(), i.ts_handler = null), i.prompt && (i.prompt.destroy(), i.prompt = null), i.state = "endCreate") : (i.firstPoint = t, i.heightfloatLabel = i.createLabel(t, ""), i.spaceDistancefloatLabel = i.createLabel(t, ""), i.horizonDistancefloatLabel = i.createLabel(t, ""))) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { var e; i.state = "creating", i.firstPoint < 1 ? i.prompt.update(t.endPosition, "单击开始测量") : (i.prompt.update(t.endPosition, "单击结束"), (t = i.getCatesian3FromPX(t.endPosition, i.viewer)) && (i.endPoint = t, i.midPoint = i.computerPoint(i.firstPoint, i.endPoint), i.firstPoint && i.endPoint && !i.spaceLine && (i.spaceLine = i.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return [i.firstPoint, i.endPoint] }, !1), show: !0, disableDepthTestDistance: Number.POSITIVE_INFINITY, material: Cesium.Color.YELLOW, width: 3, depthFailMaterial: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.YELLOW) } }), i.heightLine = i.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return [i.firstPoint, i.midPoint] }, !1), show: !0, disableDepthTestDistance: Number.POSITIVE_INFINITY, material: Cesium.Color.YELLOW, width: 3, depthFailMaterial: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.YELLOW) } }), i.horizonLine = i.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return [i.endPoint, i.midPoint] }, !1), show: !0, disableDepthTestDistance: Number.POSITIVE_INFINITY, material: Cesium.Color.YELLOW, width: 3, depthFailMaterial: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.YELLOW) } })), i.spaceLine && (t = Math.abs(Cesium.Cartographic.fromCartesian(i.firstPoint).height - Cesium.Cartographic.fromCartesian(i.endPoint).height), e = Cesium.Cartesian3.midpoint(i.firstPoint, i.midPoint, new Cesium.Cartesian3), i.heightfloatLabel.show = !0, i.heightfloatLabel.position.setValue(e), e = i.formateLength(t, i.unit), i.heightfloatLabel.label.text = "高度差：" + e, i.heightfloatLabel.length = t, e = Cesium.Cartesian3.distance(i.endPoint, i.midPoint), t = Cesium.Cartesian3.midpoint(i.endPoint, i.midPoint, new Cesium.Cartesian3), i.horizonDistancefloatLabel.show = !0, i.horizonDistancefloatLabel.position.setValue(t), t = i.formateLength(e, i.unit), i.horizonDistancefloatLabel.label.text = "水平距离：" + t, i.horizonDistancefloatLabel.length = e, t = Cesium.Cartesian3.distance(i.endPoint, i.firstPoint), e = Cesium.Cartesian3.midpoint(i.endPoint, i.firstPoint, new Cesium.Cartesian3), i.spaceDistancefloatLabel.show = !0, i.spaceDistancefloatLabel.position.setValue(e), e = i.formateLength(t, i.unit), i.spaceDistancefloatLabel.label.text = "空间距离：" + e, i.spaceDistancefloatLabel.length = t))) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.state = "no", this.heightLine && (this.viewer.entities.remove(this.heightLine), this.heightLine = null), this.spaceLine && (this.viewer.entities.remove(this.spaceLine), this.spaceLine = null), this.horizonLine && (this.viewer.entities.remove(this.horizonLine), this.horizonLine = null), this.heightfloatLabel && (this.viewer.entities.remove(this.heightfloatLabel), this.heightfloatLabel = null), this.heightfloatLabel = null, this.spaceDistancefloatLabel && (this.viewer.entities.remove(this.spaceDistancefloatLabel), this.spaceDistancefloatLabel = null), this.spaceDistancefloatLabel = null, this.horizonDistancefloatLabel && (this.viewer.entities.remove(this.horizonDistancefloatLabel), this.horizonDistancefloatLabel = null), this.horizonDistancefloatLabel = null, this.prompt && (this.prompt.destroy(), this.prompt = null), this.handler && (this.handler.destroy(), this.handler = null) } createLine(t, e) { if (t && e) return this.viewer.entities.add({ polyline: { positions: new Cesium.CallbackProperty(function () { return [t, e] }, !1), show: !0, disableDepthTestDistance: Number.POSITIVE_INFINITY, material: Cesium.Color.YELLOW, width: 3, depthFailMaterial: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.YELLOW) } }) } computerPoint(t, e) { t = Cesium.Cartographic.fromCartesian(t), e = Cesium.Cartographic.fromCartesian(e); return t.height > e.height ? Cesium.Cartesian3.fromRadians(e.longitude, e.latitude, t.height) : Cesium.Cartesian3.fromRadians(t.longitude, t.latitude, e.height) } setUnit(t) { var e = that.formateLength(this.heightfloatLabel.length, t), e = (this.heightfloatLabel.label.text = "高度差：" + e, that.formateLength(this.horizonDistancefloatLabel.length, t)), e = (this.horizonDistancefloatLabel.label.text = "水平距离：" + e, that.formateLength(this.spaceDistancefloatLabel.length, t)); this.spaceDistancefloatLabel.label.text = "空间距离：" + e, this.unit = t } } class MeasureLnglat extends BaseMeasure { constructor(t, e) { super(t, e), this.style = (e = e || {}).style || {}, this.point = null, this.position = null, this.state = 0 } start() { this.state = "startCreate"; var e = this; this.handler.setInputAction(function (t) { e.state = "endCreate"; t = e.getCatesian3FromPX(t.position, e.viewer); t && (e.position = t, e.handler && (e.handler.destroy(), e.handler = null)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { e.state = "creating"; var t = e.getCatesian3FromPX(t.endPosition, e.viewer); t && (e.position = t.clone(), Cesium.defined(e.point) || (e.point = e.createPoint()), t = cUtil$1.cartesianToLnglat(t), e.point.label.text = "经度：" + t[0].toFixed(6) + "\n纬度：" + t[1].toFixed(6) + "\n高度：" + t[2].toFixed(2) + "米") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.state = "no", this.point && (this.viewer.entities.remove(this.point), this.point = null), this.handler && (this.handler.destroy(), this.handler = null) } createPoint() { var t = this; return this.viewer.entities.add({ position: new Cesium.CallbackProperty(function () { return t.position }, !1), point: { show: !0, outlineColor: Cesium.Color.YELLOW, pixelSize: 6, outlineWidth: 3, disableDepthTestDistance: Number.MAX_VALUE }, label: { font: "24px Helvetica", fillColor: Cesium.Color.SKYBLUE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, disableDepthTestDistance: Number.POSITIVE_INFINITY, style: Cesium.LabelStyle.FILL_AND_OUTLINE, pixelOffset: new Cesium.Cartesian2(0, -60) } }) } } class MeasureAzimutht extends BaseMeasure { constructor(t, e) { super(t, e), this.style = e.style || {}, this.polyline = null, this.floatLabel = null, this.positions = [], this.mtx = null, this.azimutht = null } start(e) { let i = this; this.state = "startCreate", !this.prompt && this.promptStyle.show && (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.handler.setInputAction(function (t) { t = i.getCatesian3FromPX(t.position, i.viewer); t && (2 == i.positions.length && (i.positions.pop(), i.handler && (i.handler.destroy(), i.handler = null, i.state = "endCreate")), i.polyline || (i.polyline = i.createLine(i.positions), i.polyline.polyline.width = 5, i.polyline.polyline.material = new Cesium.PolylineArrowMaterialProperty(Cesium.Color.YELLOW)), i.positions.push(t), 1 == i.positions.length && (i.mtx = Cesium.Transforms.eastNorthUpToFixedFrame(i.positions[0].clone()), i.floatLabel = i.createLabel(t, ""), e && e(i.azimutht))) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (e) { if (i.positions.length < 1) i.prompt.update(e.endPosition, "单击开始测量"); else { i.prompt.update(e.endPosition, "单击结束"), i.state = "creating"; let t = i.getCatesian3FromPX(e.endPosition, i.viewer); t && (i.positions.length < 2 ? i.positions.push(t.clone()) : i.positions[1] = t.clone(), i.floatLabel && (i.azimutht = i.getAzimuthtAndCenter(i.mtx, i.positions), i.floatLabel.label.text = "方位角：" + i.azimutht.toFixed(2))) } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.floatLabel && (this.viewer.entities.remove(this.floatLabel), this.floatLabel = null), this.floatLable = null, this.handler && (this.handler.destroy(), this.handler = null), this.state = "no", this.prompt && (this.prompt.destroy(), this.prompt = null) } } class MeasureSection extends BaseMeasure { constructor(t, e) { super(t, e), this.style = e.style || {}, this.viewer = t, this.polyline = null, this.positions = [], this.movePush = !1, this.prompt, this.isStart = !1, this.firstPosition = null, this.state = "no" } start(e) { !this.prompt && this.promptStyle.show && (this.prompt = new Prompt(this.viewer, this.promptStyle)); var i = this; i.state = "startCreate", this.handler.setInputAction(function (t) { t = i.getCatesian3FromPX(t.position, i.viewer); t && (i.isStart ? (i.handler && (i.handler.destroy(), i.handler = null), i.prompt && (i.prompt.destroy(), i.prompt = null), i.getHeight(i.positions, function (t) { e(t) }), i.state = "endCreate") : (i.isStart = !0, i.firstPosition = t)) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { var e; i.state = "creating", i.isStart ? (i.prompt.update(t.endPosition, "再次单击结束"), e = i.getCatesian3FromPX(t.endPosition, i.viewer), i.positions = [i.firstPosition, e], i.polyline || (i.polyline = i.viewer.entities.add({ polyline: { show: !0, positions: new Cesium.CallbackProperty(function () { return i.positions }, !1), material: Cesium.Color.GREEN, width: 3, clampToGround: !0 } }))) : i.prompt.update(t.endPosition, "单击开始") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.polyline && (this.viewer.entities.remove(this.polyline), this.polyline = null), this.prompt && (this.prompt.destroy(), this.prompt = null), this.handler && (this.handler.destroy(), this.handler = null), this.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY), this.viewer.trackedEntity = void 0, this.state = "no" } getHeight(o, s) { var e, n; !o || o.length < 1 || (o = cUtil.lerpPositions(o), e = [], o.forEach(function (t) { e.push(Cesium.Cartographic.fromCartesian(t)) }), !e || e.length < 1 || (n = Cesium.Cartographic.fromCartesian(o[0]).height, Cesium.when(Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, e), function (t) { for (var e = 0; e < t.length; e++) { var i = t[e]; i.height = i.height || n } s && s({ positions: o, lnglats: t }) }))) } } class MeasureSlope extends BaseMeasure { constructor(t, e) { super(t, e = e || {}), this.style = e.style || {}, this.viewer = t, this.label = null, this.point = null } start() { this.state = "startCreate"; var i = this; this.handler.setInputAction(function (t) { i.handler && (i.handler.destroy(), i.handler = null, i.state = "endCreate") }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (t) { i.state = "creating"; var e = i.getCatesian3FromPX(t.endPosition, i.viewer); e && (i.point || (i.point = i.createPoint(e)), i.point.position.setValue(e), i.getSlope(e, function (t) { i.label || (i.label = i.createLabel(e, "")), i.label.position.setValue(e), i.label.label.text = "坡度：" + t.toFixed(2) + "°" })) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.state = "no", this.label && (this.viewer.entities.remove(this.label), this.label = null), this.point && (this.viewer.entities.remove(this.point), this.point = null), this.handler && (this.handler.destroy(), this.handler = null) } createPoint(t) { return this.viewer.entities.add({ position: t, point: { heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, show: !0, fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.RED, outlineWidth: 2, outlineWidth: 3, pixelSize: 6, disableDepthTestDistance: Number.MAX_VALUE } }) } } class MeasureTool { constructor(t, e) { t ? (e = e || {}, this.viewer = t, this.nowMeasureObj = null, this.toolArr = [], this.lastMeasureObj = null, this.handler = null, this.canEdit = null == e.canEdit || e.canEdit, this.intoEdit = null == e.intoEdit || e.intoEdit, this.bindEdit()) : console.warn("缺少必要参数！--viewer") } on(t, e) { "endMeasure" == t && (this.endMeasureFun = e), "startEdit" == t && (this.startEditFun = e), "endEdit" == t && (this.endEditFun = e) } start(o) { if ((o = o || {}).type) { let i; if (!this.nowMeasureObj || "endCreate" == this.nowMeasureObj.state || "endEdit" == this.nowMeasureObj.state || "no" == measureTool.nowMeasureObj.state) { switch (Number(o.type)) { case 1: i = new MeasureSpaceDistance(this.viewer, o); break; case 2: i = new MeasureGroundDistance(this.viewer, o); break; case 3: i = new MeasureSpaceArea(this.viewer, o); break; case 4: i = new MeasureHeight(this.viewer, o); break; case 5: i = new MeasureTriangle(this.viewer, o); break; case 6: i = new MeasureLnglat(this.viewer, o); break; case 7: i = new MeasureAzimutht(this.viewer, o); break; case 8: i = new MeasureSection(this.viewer, o); break; case 9: i = new MeasureSlope(this.viewer, o); break; case 11: i = new MeasureSlopePolygon(this.viewer) }this.nowMeasureObj = i; let e = this; i && (i.start(function (t) { e.intoEdit && (i.startEdit(), e.startEditFun && e.startEditFun(i), e.lastMeasureObj = i), o.success && o.success(i, t), e.endMeasureFun && e.endMeasureFun(i, t) }), this.toolArr.push(i)) } } } bindEdit() { let i = this; this.handler || (this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas)), this.handler.setInputAction(function (t) { if (i.canEdit) { var e = i.viewer.scene.pick(t.position); if (Cesium.defined(e) && e.id && e.id.objId) { for (let t = 0; t < i.toolArr.length; t++)if (e.id.objId == i.toolArr[t].objId && ("endCreate" == i.toolArr[t].state || "endEdit" == i.toolArr[t].state)) { i.lastMeasureObj && (i.lastMeasureObj.endEdit(), i.endEditFun && i.endEditFun(i.lastMeasureObj), i.lastMeasureObj = null), i.toolArr[t].startEdit(), i.nowEditObj = i.toolArr[t], i.startEditFun && i.startEditFun(i.nowEditObj), i.lastMeasureObj = i.toolArr[t]; break } } else i.lastMeasureObj && (i.lastMeasureObj.endEdit(), i.endEditFun && i.endEditFun(i.lastMeasureObj), i.lastMeasureObj = null) } }, Cesium.ScreenSpaceEventType.LEFT_CLICK) } endEdit() { this.lastMeasureObj && (this.lastMeasureObj.endEdit(), this.endEditFun && this.endEditFun(this.lastMeasureObj, this.lastMeasureObj.getEntity()), this.lastMeasureObj = null); for (let t = 0; t < this.toolArr.length; t++)this.toolArr[t].endEdit() } clear() { for (var t = 0; t < this.toolArr.length; t++)this.toolArr[t] && this.toolArr[t].destroy(); this.toolArr = [], this.nowMeasureObj = null } destroy() { this.clear(), this.handler && (this.handler.destroy(), this.handler = null) } setUnit(t) { t && this.nowMeasureObj.setUnit(t) } } class LatlngNavigation {
    constructor(t, e) { this.viewer = t, this.moveHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.initHtml(), this.bindMouseMoveHandler(), this.ellipsoid = this.viewer.scene.globe.ellipsoid } bindMouseMoveHandler() { let s = this; this.moveHandler.setInputAction(function (t) { var e, i, o, t = s.getCatesian3FromPX(t.endPosition); t && (t = s.ellipsoid.cartesianToCartographic(t), e = Cesium.Math.toDegrees(t.latitude), i = Cesium.Math.toDegrees(t.longitude), t = t.height, o = s.getCameraView(), s.setHtml({ lng: i, lat: e, height: t }, o)) }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } destroy() { this.moveHandler && (this.moveHandler.destroy(), this.moveHandler = null); var t = document.getElementsByClassName("easy3d-lnglatNavigation"), e = this.viewer.container.id; const i = document.getElementById(e); i.removeChild(t[0]) } initHtml() {
        var t = this.viewer.container.id; const e = document.getElementById(t); let i = document.createElement("div"); i.className = "easy3d-lnglatNavigation", i.innerHTML = ` <ul>
                            <li></li>   
                            <li></li>
                            <li></li>
                            <li></li>
                            <li></li>
                            <li></li>
                            <li></li>
                        <ul>`, e.appendChild(i)
    } getCatesian3FromPX(t) { var e = this.viewer.scene.drillPick(t); this.viewer.scene.render(); let i, o = !1; for (let t = 0; t < e.length; t++)if (e[t] && e[t].primitive && e[t].primitive instanceof Cesium.Cesium3DTileset) { o = !0; break } if (o) i = this.viewer.scene.pickPosition(t); else { t = this.viewer.camera.getPickRay(t); if (!t) return null; i = this.viewer.scene.globe.pick(t, this.viewer.scene) } return i } setHtml(e, i) { var o = Number(e.lng).toFixed(6), s = Number(e.lat).toFixed(6), e = Number(e.height).toFixed(2), n = Number(i.heading).toFixed(2), r = Number(i.pitch).toFixed(2), a = Number(i.roll).toFixed(2), i = Number(i.z).toFixed(2), l = document.getElementsByClassName("easy3d-lnglatNavigation"); if (l && !(l.length < 1)) { let t = l[0].children[0].children; t[0].innerHTML = "经度：" + o, t[1].innerHTML = "纬度：" + s, t[2].innerHTML = "高度：" + e, t[3].innerHTML = "偏转角：" + n, t[4].innerHTML = "仰俯角：" + r, t[5].innerHTML = "翻滚角：" + a, t[6].innerHTML = "相机高度：" + i } } getCameraView() { var t = this.viewer.camera, e = t.position, i = t.heading, o = t.pitch, t = t.roll, e = Cesium.Cartographic.fromCartesian(e); return { x: Cesium.Math.toDegrees(e.longitude), y: Cesium.Math.toDegrees(e.latitude), z: e.height, heading: Cesium.Math.toDegrees(i), pitch: Cesium.Math.toDegrees(o), roll: Cesium.Math.toDegrees(t) } }
} class GaodeRoute { constructor(t) { this._keys = (t = t || {}).key || ["ae29a37307840c7ae4a785ac905927e0", "888a52a74c55ca47abe6c55ab3661d11", "0bc2903efcb3b67ebf1452d2f664a238", "0df8f6f984adc49fca5b7b1108664da2", "72f75689dff38a781055e68843474751"], this.GaodeRouteType = { Walking: 1, Bicycling: 2, Driving: 3 }, this._key_index = 0 } get keys() { return this._keys } set keys(t) { this._keys = t } get key() { var t = this._key_index++ % this._keys.length; return this._keys[t] } query(i) { var t = { key: this.key, output: "json" }, e = cUtil$1.wgs2gcj(i.points[0]), o = cUtil$1.wgs2gcj(i.points[i.points.length - 1]); if (t.origin = e[0] + "," + e[1], t.destination = o[0] + "," + o[1], i.avoidareas) { let e = ""; for (let t = 0; t < i.avoidareas.length; t++) { var s = i.avoidareas[t]; e += `${s[0]},${s[1]};` } t.avoidpolygons = e } switch (i.type) { default: case this.GaodeRouteType.Walking: this.queryWalking(t, i); break; case this.GaodeRouteType.Bicycling: this.queryBicycling(t, i); break; case this.GaodeRouteType.Driving: this.queryDriving(t, i) } } queryList(i) { var t, o = this, s = -1, n = {}; for (t in i) "points" != t && "success" != t && "error" != t && (n[t] = i[t]); var r = i.points, a = []; !function e() { s++, n.points = r[s], n.success = function (t) { t && t.paths && 0 < t.paths.length ? a.push(t.paths[0]) : a.push(null), s >= r.length - 1 ? i.success && i.success(a) : e() }, n.error = n.success, o.query(n) }() } computeMindistanceLine(t) { for (var e = Number.MAX_VALUE, i = null, o = -1, s = 0; s < t.length; s++) { var n = t[s]; n && n.allDistance <= e && (o = s, e = (i = n).allDistance) } return { lineData: i, index: o } } queryWalking(i, o) { var s = this; axios.get("http://restapi.amap.com/v3/direction/walking", { params: i }).then(function (t) { var e, t = t.data || {}; "10000" !== t.infocode ? (e = "路径规划 请求失败(" + t.infocode + ")：" + t.info, o.error && o.error(e)) : t.route && t.route.paths ? (t = s._formatRouteData(i.origin, i.destination, t.route.paths), o.success && o.success(t)) : (e = "未查询到相关结果！", o.error && o.error(e)) }).catch(function (t) { o.error && o.error(t) }) } queryBicycling(i, o) { var s = this; axios.get("https://restapi.amap.com/v4/direction/bicycling", { params: i }).then(function (t) { var e, t = t.data || {}; "10000" !== t.infocode ? (e = "路径规划 请求失败(" + t.infocode + ")：" + t.info, o.error && o.error(e)) : t.route && t.route.paths ? (t = s._formatRouteData(i.origin, i.destination, t.route.paths), o.success && o.success(t)) : (e = "未查询到相关结果！", o.error && o.error(e)) }).catch(function (t) { o.error && o.error(t) }) } queryDriving(i, o) { i.extensions = o.extensions || "base", i.strategy = o.strategy || 0; var s = this; axios("https://restapi.amap.com/v3/direction/driving", { params: i }).then(function (t) { var e, t = t.data || {}; "10000" !== t.infocode ? (e = "路径规划 请求失败(" + t.infocode + ")：" + t.info, o.error && o.error(e)) : t.route && t.route.paths && 0 != t.route.paths.length ? (t = s._formatRouteData(i.origin, i.destination, t.route.paths), o.success && o.success(t)) : (e = "未查询到相关结果！", o.error && o.error(e)) }).catch(function (t) { o.error && o.error(t) }) } _formatRouteData(t, e, i) { var o, s, n = []; if (t && (o = cUtil$1.gcj2wgs(t.split(","))), e && (s = cUtil$1.gcj2wgs(e.split(","))), i && 0 < i.length) for (var r = 0; r < i.length; r++) { for (var a = [], l = (a.push(o), i[r]), h = l.steps, c = [], d = [], u = 0; u < h.length; u++) { for (var p = { instruction: h[u].instruction, distance: h[u].distance, duration: h[u].duration, points: [], route: h[u].road }, m = h[u].polyline.split(";"), g = 0; g < m.length; g++) { var C = m[g], C = cUtil$1.gcj2wgs(C.split(",")); a.push(C), p.points.push(C) } d.push(p.route), c.push(p) } a.push(s), n.push({ allDistance: l.distance, allDuration: l.duration, steps: c, points: a, road: d }) } return { origin: o, destination: s, paths: n } } } var gadgets = { GaodeRoute: GaodeRoute }; class Roam { constructor(t, e) { console.log("漫游对象属性--》", e), this.viewer = t, this.objId = Number((new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0)), this.opt = e || {}, this.startTime = e.startTime ? Cesium.JulianDate.fromDate(e.startTime, new Cesium.JulianDate) : this.viewer.clock.currentTime.clone(), this.endTime = null, this.opt.positions ? (this.positions = this.transfromPositions(this.opt.positions), this.clockSpeed = 1, this.stopTime = null, this.alldistance = 0, this.alltimes = 0, this.distanceED = -1, this.timesED = -1, this.speed = 0, this.viewType = "none", this.rendHandler = null, this.isLockView = !1, this.viewXYZ = { x: 0, y: 0, z: 0 }, this.endRoamCallback = e.endRoamCallback, this.roamingCallback = e.roamingCallback, this.init(), this.setViewType(e.viewType)) : console.log("缺少漫游坐标") } init() { let t = {}; if (this.opt.times) this.endTime = Cesium.JulianDate.addSeconds(this.startTime, this.opt.times, new Cesium.JulianDate), t = this.createPropertyByTimes(this.positions, this.opt.times); else { if (!this.opt.speed) return void console.log("缺少漫游时长或速度参数！"); t = this.createPropertyBySpeed(this.positions, this.opt.speed) } this.alldistance = t.alldistance, this.alltimes = t.alltimes, this.speed = t.speed, this.roamEntity = this.createRoamEntity(this.opt.entityType, t.property) } setPositions(t) { this.destroy(), this.positions = t, this.init() } start() { this.roamEntity && (this.roamEntity.show = !0), this.clockSpeed = 1, this.viewer.clock.currentTime = this.startTime, this.viewer.clock.multiplier = this.clockSpeed, this.viewer.clock.shouldAnimate = !0, this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP, this.computeCamera() } end() { this.roamEntity && (this.roamEntity.show = !1), this.viewer.clock.currentTime = this.endTime, this.viewer.clock.shouldAnimate = !1, this.distanceED = this.alldistance, this.timesED = this.alltimes, this.endRoamCallback && this.endRoamCallback(this.opt) } stop() { this.stopTime = this.viewer.clock.currentTime.clone(), this.viewer.clock.shouldAnimate = !1, this.roamingFun && this.roamingFun() } goon() { this.stopTime && (this.viewer.clock.currentTime = this.stopTime.clone(), this.viewer.clock.shouldAnimate = !0, this.stopTime = null) } setSpeed(t) { this.clockSpeed = t, this.viewer.clock.multiplier = this.clockSpeed } destroy() { this.roamEntity && (this.viewer.entities.remove(this.roamEntity), this.roamEntity = null), this.rendHandler && (this.rendHandler(), this.rendHandler = null), this.viewer.clock.multiplier = 1, this.isLockView = !1, this.viewer.trackedEntity = void 0, this.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY) } createRoamEntity(t, e) { let i = null; if ("model" == t) { if (!this.opt.entityAttr || !this.opt.entityAttr.uri) return void console.log("漫游缺少模型对象！"); i = this.viewer.entities.add({ orientation: new Cesium.VelocityOrientationProperty(e), position: e, model: this.opt.entityAttr }) } else if ("image" == t) { if (!this.opt.entityAttr || !this.opt.entityAttr.image) return void console.log("漫游缺少图片对象！"); i = this.viewer.entities.add({ orientation: new Cesium.VelocityOrientationProperty(e), position: e, billboard: this.opt.entityAttr }) } else i = this.viewer.entities.add({ orientation: new Cesium.VelocityOrientationProperty(e), position: e, point: { pixelSize: .001, color: Cesium.Color.WHITE.withAlpha(1e-4) } }); return i.show = !1, i } transfromPositions(t) { if (t) { if (t[0] instanceof Cesium.Cartesian3) return t; { let e = []; return t.forEach(t => { t = Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2] || 0); e.push(t) }), e } } } computeCamera() { let i = this, o = new Cesium.Matrix4, s = (this.distanceED = 0, this.timeED = 0, null); this.rendHandler || (this.rendHandler = this.viewer.scene.preRender.addEventListener(function (t) { var e; i.viewer.clock.shouldAnimate && i.roamEntity && (e = i.viewer.clock.currentTime, Cesium.JulianDate.compare(i.endTime, e) < 0 ? i.end() : (i.roamingCallback && i.roamingCallback(i.distanceED, i.timesED), i.isLockView && (i.getModelMatrix(i.roamEntity, i.viewer.clock.currentTime, o), i.viewer.scene.camera.lookAtTransform(o, new Cesium.Cartesian3(-i.viewXYZ.x, i.viewXYZ.y, i.viewXYZ.z))), i.timeED = Cesium.JulianDate.secondsDifference(e, i.startTime), (e = i.roamEntity.position.getValue(e)) && s && (i.distanceED += Cesium.Cartesian3.distance(e, s)), s = e)) })) } getModelMatrix(t, e, i) { if (t) { var o = Cesium.Property.getValueOrUndefined(t.position, e, new Cesium.Cartesian3); if (Cesium.defined(o)) return (t = Cesium.Property.getValueOrUndefined(t.orientation, e, new Cesium.Quaternion)) ? Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(t, new Cesium.Matrix3), o, i) : Cesium.Transforms.eastNorthUpToFixedFrame(o, void 0, i) } } createPropertyByTimes(n, r) { if (n && !(n.length < 2)) { let o = new Cesium.SampledPositionProperty, e = 0; for (let t = 1; t < n.length; t++) { var i = n[t - 1], a = n[t], i = Cesium.Cartesian3.distance(i, a); e += i } var l = e / r; let s = 0; for (let i = 0; i < n.length; i++) { let t = n[i], e; if (0 == i) e = this.startTime.clone(); else { var h = n[i - 1], h = Cesium.Cartesian3.distance(t, h); const r = (s += h) / l; e = Cesium.JulianDate.addSeconds(this.startTime.clone(), r, new Cesium.JulianDate) } o.addSample(e.clone(), t.clone()) } return { property: o, alldistance: e, alltimes: r, speed: l } } } createPropertyBySpeed(n, r) { if (n && !(n.length < 2)) { let o = new Cesium.SampledPositionProperty, e = 0; for (let t = 1; t < n.length; t++) { var i = n[t - 1], a = n[t], i = Cesium.Cartesian3.distance(i, a); e += i } let s = 0; for (let i = 0; i < n.length; i++) { let t = n[i], e; var l; e = 0 == i ? this.startTime.clone() : (l = n[i - 1], l = Cesium.Cartesian3.distance(t, l), l = (s += l) / r, Cesium.JulianDate.addSeconds(this.startTime.clone(), l, new Cesium.JulianDate)), o.addSample(e.clone(), t.clone()) } return { property: o, alldistance: e, alltimes: e / r, speed: r } } } setViewType(t) { switch (this.viewType = t, this.viewType) { case "dy": this.isLockView = !0, this.viewXYZ = { x: 100, y: 0, z: 10 }; break; case "sd": this.isLockView = !0, this.viewXYZ = { x: 0, y: 0, z: 5e3 }; break; case "gs": this.isLockView = !1, this.viewer.trackedEntity = void 0; break; default: this.isLockView = !1, this.viewer.trackedEntity = void 0, this.viewer.scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY) } } setTrackView(t) { this.isLockView = !0, this.viewXYZ = t } getAttr() { var t = { viewType: this.viewType, alldistance: this.alldistance, alltimes: this.alltimes, distanceED: this.distanceED, times: this.distanceED, viewType: this.viewType }; return Object.assign(this.opt, t) } } class RoamTool { constructor(t, e) { this.viewer = t, this.opt = e || {}, this.startRoamFun = null, this.endRoamFun = null, this.roamingFun = null, this.stopRoamFun = null, this.goonRoamFun = null, this.endCreateFun = null, this.roamList = [], this.nowStartRoam = null } on(t, e) { "startRoam" == t && (this.startRoamFun = e), "endRoam" == t && (this.endRoamFun = e), "roaming" == t && (this.roamingFun = e), "stopRoam" == t && (this.stopRoamFun = e), "goonRoam" == t && (this.goonRoamFun = e), "endCreate" == t && (this.endCreateFun = e) } create(t, e) { var i, { roamType: o, positions: s } = t = t || {}, s = this.transfromPositions(s); let n = null, r = { times: t.times, speed: t.speed, endRoamCallback: this.endRoamFun, roamingCallback: this.roamingFun, viewType: t.viewType }, a = (t.times || t.speed || (r.times = 60), r = Object.assign(t, r), this); switch (o) { case 1: t.height ? (i = this.updatePositionsHeight(s, t.height), r.positions = i, (n = new Roam(this.viewer, r)).attr = r, this.roamList.push(n), e && e(n)) : console.log("飞行漫游缺少高度！"); break; case 2: this.getTerrainPositions(s, function (t) { r.positions = t, (n = new Roam(a.viewer, r)).attr = r, a.roamList.push(n), e && e(n) }); break; case 3: break; default: r.positions = s, (n = new Roam(this.viewer, r)).attr = r, this.roamList.push(n), e && e(n) } } transfromPositions(t) { if (t) { if (t[0] instanceof Cesium.Cartesian3) return t; if (t[0].x && t[0].y && t[0].z) { let e = []; return t.forEach(t => { e.push(new Cesium.Cartesian3(t.x, t.y, t.z)) }), e } { let e = []; return t.forEach(t => { t = Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2] || 0); e.push(t) }), e } } } updatePositionsHeight(t, o) { if (t && !(t.length < 2)) { let i = []; return t.forEach(t => { let e = Cesium.Cartographic.fromCartesian(t.clone()); e.height = o; t = Cesium.Cartographic.toCartesian(e); i.push(t) }), i } } getTerrainPositions(i, o) { if (i && !(i.length < 2)) { let e = []; for (let t = 0; t < i.length; t++) { var s = i[t], s = Cesium.Cartographic.fromCartesian(s); e.push(s) } Cesium.when(Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, e), function (t) { t = ellipsoid.cartographicArrayToCartesianArray(t); o && o(t) }) } } getRoamByField(e, i) { if (!e) return []; let o = []; for (let t = 0; t < this.roamList.length; t++) { var s = this.roamList[t]; s.attr[e] == i && o.push({ roam: s, index: t }) } return o } removeRoamById(i) { if (i) for (let e = this.roamList.length - 1; 0 <= e; e--) { let t = this.roamList[e]; if (t.objId == i) { t.destroy(), this.roamList.splice(e, 1); break } } } removeRoam(t) { t && (t = t.objId, this.removeRoamById(t)) } startRoam(t) { this.endRoam(); var i = t.objId; for (let e = this.roamList.length - 1; 0 <= e; e--) { let t = this.roamList[e]; if (t.objId == i) { t.start(), this.nowStartRoam = t, this.startRoamFun && this.startRoamFun(t); break } } } endRoam() { this.nowStartRoam && (this.nowStartRoam.end(), this.nowStartRoam = null) } getNowroamAttr() { return this.nowStartRoam ? Object.assign(this.nowStartRoam.attr, this.nowStartRoam.getAttr()) : {} } destroy() { for (let e = this.roamList.length - 1; 0 <= e; e--) { let t = this.roamList[e]; t.destroy() } this.roamList = [] } toJson() { let i = []; for (let e = this.roamList.length - 1; 0 <= e; e--) { let t = this.roamList[e]; i.push(t.getAttr()) } return i } } class ZoomTool { constructor(t, e) { this.viewer = t, this.opt = e || {}, this.step = this.opt.step || .5, this.forwardAmount = null, this.backwardAmount = null, this.position = null } forward() { let t; this.backwardAmount ? (t = this.backwardAmount, this.backwardAmount = null) : (t = this.computeLength() || 1e4, t *= this.step), this.viewer.camera.moveForward(t), this.forwardAmount = t } backward() { let t; this.forwardAmount ? (t = this.forwardAmount, this.forwardAmount = null) : (t = this.computeLength() || 1e4, t *= this.step), this.viewer.camera.moveBackward(t), this.backwardAmount = t } computeLength() { this.position = this.viewer.camera.position; var t = Cesium.Cartographic.fromCartesian(this.position).height, e = this.viewer.camera.direction, e = Cesium.Cartesian3.normalize(e, new Cesium.Cartesian3), i = new Cesium.Cartesian3(0, 0, -1), e = Cesium.Cartesian3.dot(e, i), i = Math.asin(e); return t / Math.cos(i) } } class OverviewMap { constructor(t, e) { this.viewer = t, this.opt = e || {}; this.style = Object.assign({ height: 150, width: 200, bottom: 30, right: 60 }, this.opt.style), this.rectangle = null, this.init() } init() { this.mapEle = window.document.createElement("div"), this.mapEle.setAttribute("id", "map2d"), this.mapEle.style.height = this.style.height + "px", this.mapEle.style.width = this.style.width + "px", this.mapEle.style.position = "absolute", this.mapEle.style.bottom = this.style.bottom + "px", this.mapEle.style.right = this.style.right + "px", document.body.appendChild(this.mapEle), this.showStyle = { color: "#ff7800", weight: 1, fill: !0, stroke: !0, opacity: 1 }, this.hideStyle = { fill: !1, opacity: 0 }; var t = L.map("map2d", { minZoom: 3, maxZoom: 17, center: [31.827107, 117.240601], zoom: 4, zoomControl: !1, attributionControl: !1 }); L.tileLayer("http://a.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(t), this.map = t, this.viewer.camera.percentageChanged = .01, this.viewer.camera.changed.addEventListener(this.sceneRenderHandler, this), this.sceneRenderHandler() } sceneRenderHandler() { var t = this.viewer.camera.computeViewRectangle(); let e = {}; t ? (e.ymin = Cesium.Math.toDegrees(t.south), e.ymax = Cesium.Math.toDegrees(t.north), e.xmin = Cesium.Math.toDegrees(t.west), e.xmax = Cesium.Math.toDegrees(t.east)) : (e.ymin = -90, e.ymax = 90, e.xmin = -180, e.xmin = 180); var t = L.latLng(e.ymin, e.xmin), i = L.latLng(e.ymax, e.xmax); let o = L.latLngBounds(t, i); this.rectangle ? this.rectangle.setBounds(o) : this.rectangle = L.rectangle(o, this.showStyle).addTo(this.map), -180 == e.xmin && 180 == e.xmax && 90 == e.ymax && -90 == e.ymin ? (this.map.setView([0, 0], 0), this.rectangle.setStyle(this.hideStyle)) : (t = o.pad(.5), this.map.fitBounds(t), this.rectangle.setStyle(this.showStyle)) } hide() { this.mapEle && (this.mapEle.style.display = "none") } show() { this.map && this.mapEle && (this.mapEle.style.display = "block") } setStyle(t) { t && (this.showStyle = t) } destroy() { this.mapEle && document.body.removeChild(this.mapEle), this.viewer.camera.changed.removeEventListener(this.sceneRenderHandler, this) } } var htmlTagRegex = /<html(.|\s)*>(.|\s)*<\/html>/im, md = new MarkdownIt({ html: !0, linkify: !0 }), KnockoutMarkdownBinding = (md.use(MarkdownItSanitizer, { imageClass: "", removeUnbalanced: !1, removeUnknown: !1 }), { register: function (n) { n.bindingHandlers.markdown = { init: function () { return { controlsDescendantBindings: !0 } }, update: function (t, e) { for (; t.firstChild;)n.removeNode(t.firstChild); var e = n.unwrap(e()), e = htmlTagRegex.test(e) ? e : md.render(e), i = n.utils.parseHtmlFragment(e, t); t.className = t.className + " markdown"; for (var o = 0; o < i.length; ++o) { var s = i[o]; setAnchorTargets(s), t.appendChild(s) } } } } }); function setAnchorTargets(t) { if (t instanceof HTMLAnchorElement && (t.target = "_blank"), t.childNodes && 0 < t.childNodes.length) for (var e = 0; e < t.childNodes.length; ++e)setAnchorTargets(t.childNodes[e]) } let cesium = require("cesium/Cesium.js"); var KnockoutHammerBinding = { register: function (r) { r.bindingHandlers.swipeLeft = { init: function (t, e, i, o, s) { var n = r.unwrap(e()); new Hammer(t).on("swipeleft", function (t) { var e = s.$data; n.apply(e, arguments) }) } }, r.bindingHandlers.swipeRight = { init: function (t, e, i, o, s) { var n = r.unwrap(e()); new Hammer(t).on("swiperight", function (t) { var e = s.$data; n.apply(e, arguments) }) } } } }; let cesium$1 = require("cesium/Cesium.js"), { knockout, SvgPathBindingHandler } = cesium$1; var Knockout = knockout, registerKnockoutBindings = function () { SvgPathBindingHandler.register(Knockout), KnockoutMarkdownBinding.register(Knockout), KnockoutHammerBinding.register(Knockout), Knockout.bindingHandlers.embeddedComponent = { init: function (t, e, i, o, s) { return Knockout.unwrap(e()).show(t), { controlsDescendantBindings: !0 } }, update: function (t, e, i, o, s) { } } }; const createFragmentFromTemplate = function (t) { for (var e = document.createElement("div"), i = (e.innerHTML = t, document.createDocumentFragment()); e.firstChild;)i.appendChild(e.firstChild); return i }; let cesium$2 = require("cesium/Cesium.js"), { knockout: knockout$1, getElement } = cesium$2; var Knockout$1 = knockout$1, loadView = function (t, e, i) { e = getElement(e); for (var o = createFragmentFromTemplate(t), s = [], n = 0; n < o.childNodes.length; ++n)s.push(o.childNodes[n]); for (e.appendChild(o), n = 0; n < s.length; ++n) { var r = s[n]; 1 !== r.nodeType && 8 !== r.nodeType || Knockout$1.applyBindings(i, r) } return s }; let cesium$3 = require("cesium/Cesium.js"), { defined, DeveloperError, EllipsoidGeodesic, Cartesian2, getTimestamp, EventHelper, knockout: knockout$2 } = cesium$3; var Knockout$2 = knockout$2, DistanceLegendViewModel = function (t) { if (!defined(t) || !defined(t.terria)) throw new DeveloperError("options.terria is required."); this.terria = t.terria, this._removeSubscription = void 0, this._lastLegendUpdate = void 0, this.eventHelper = new EventHelper, this.distanceLabel = void 0, this.barWidth = void 0, this.enableDistanceLegend = !defined(t.enableDistanceLegend) || t.enableDistanceLegend, Knockout$2.track(this, ["distanceLabel", "barWidth"]), this.eventHelper.add(this.terria.afterWidgetChanged, function () { defined(this._removeSubscription) && (this._removeSubscription(), this._removeSubscription = void 0) }, this); var e = this; function i() { var t; defined(e.terria) && (t = e.terria.scene, e._removeSubscription = t.postRender.addEventListener(function () { updateDistanceLegendCesium(this, t) }, e)) } i(), this.eventHelper.add(this.terria.afterWidgetChanged, function () { i() }, this) }, geodesic = (DistanceLegendViewModel.prototype.destroy = function () { this.eventHelper.removeAll() }, DistanceLegendViewModel.prototype.show = function (t) { var e = this.enableDistanceLegend ? '<div class="distance-legend" id="easy3d-distance-legend" data-bind="visible: distanceLabel && barWidth"><div class="distance-legend-label" data-bind="text: distanceLabel"></div><div class="distance-legend-scale-bar" data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div></div>' : '<div class="distance-legend" id="easy3d-distance-legend" style="display: none;" data-bind="visible: distanceLabel && barWidth"><div class="distance-legend-label"  data-bind="text: distanceLabel"></div><div class="distance-legend-scale-bar"  data-bind="style: { width: barWidth + \'px\', left: (5 + (125 - barWidth) / 2) + \'px\' }"></div></div>'; loadView(e, t, this) }, DistanceLegendViewModel.create = function (t) { var e = new DistanceLegendViewModel(t); return e.show(t.container), e.setStyle(t.style), e }, DistanceLegendViewModel.prototype.setStyle = function (e) { if (e && !(Object.keys(e).length < 1)) { let t = document.getElementById("easy3d-distance-legend"); if (t) for (var i in e) t.style[i] = e[i] } }, new EllipsoidGeodesic), distances = [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1e3, 2e3, 3e3, 5e3, 1e4, 2e4, 3e4, 5e4, 1e5, 2e5, 3e5, 5e5, 1e6, 2e6, 3e6, 5e6, 1e7, 2e7, 3e7, 5e7]; function updateDistanceLegendCesium(t, e) { if (t.enableDistanceLegend) { var i = getTimestamp(); if (!(i < t._lastLegendUpdate + 250)) { t._lastLegendUpdate = i; var i = e.canvas.clientWidth, o = e.canvas.clientHeight, s = e.camera.getPickRay(new Cartesian2(i / 2 | 0, o - 1)), i = e.camera.getPickRay(new Cartesian2(1 + i / 2 | 0, o - 1)), o = e.globe, s = o.pick(s, e), i = o.pick(i, e); if (defined(s) && defined(i)) { for (var n, e = o.ellipsoid.cartesianToCartographic(s), s = o.ellipsoid.cartesianToCartographic(i), r = (geodesic.setEndPoints(e, s), geodesic.surfaceDistance), a = distances.length - 1; !defined(n) && 0 <= a; --a)distances[a] / r < 100 && (n = distances[a]); defined(n) ? (o = 1e3 <= n ? (n / 1e3).toString() + " km" : n.toString() + " m", t.barWidth = n / r | 0, t.distanceLabel = o) : (t.barWidth = void 0, t.distanceLabel = void 0) } else t.barWidth = void 0, t.distanceLabel = void 0 } } else t.barWidth = void 0, t.distanceLabel = void 0 } var svgReset = "M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z"; let cesium$4 = require("cesium/Cesium.js"), { defined: defined$1, DeveloperError: DeveloperError$1, knockout: knockout$3 } = cesium$4; var Knockout$3 = knockout$3, UserInterfaceControl = function (t) { if (!defined$1(t)) throw new DeveloperError$1("terria is required"); this._terria = t, this.name = "Unnamed Control", this.text = void 0, this.svgIcon = void 0, this.svgHeight = void 0, this.svgWidth = void 0, this.cssClass = void 0, this.isActive = !1, Knockout$3.track(this, ["name", "svgIcon", "svgHeight", "svgWidth", "cssClass", "isActive"]) }, NavigationControl = (Object.defineProperties(UserInterfaceControl.prototype, { terria: { get: function () { return this._terria } }, hasText: { get: function () { return defined$1(this.text) && "string" == typeof this.text } } }), UserInterfaceControl.prototype.activate = function () { throw new DeveloperError$1("activate must be implemented in the derived class.") }, function (t) { UserInterfaceControl.apply(this, arguments) }); NavigationControl.prototype = Object.create(UserInterfaceControl.prototype); let cesium$5 = require("cesium/Cesium.js"), { defined: defined$2, Camera, Rectangle, Cartographic, Math: Math$1 } = cesium$5; var ResetViewNavigationControl = function (t) { NavigationControl.apply(this, arguments), this.name = "重置视图", this.navigationLocked = !1, this.svgIcon = svgReset, this.svgHeight = 15, this.svgWidth = 15, this.cssClass = "navigation-control-icon-reset" }; ResetViewNavigationControl.prototype = Object.create(NavigationControl.prototype), ResetViewNavigationControl.prototype.setNavigationLocked = function (t) { this.navigationLocked = t }, ResetViewNavigationControl.prototype.resetView = function () { var t, e; this.navigationLocked || (t = this.terria.scene).screenSpaceCameraController.enableInputs && (this.isActive = !0, t = t.camera, defined$2(this.terria.trackedEntity) ? (e = this.terria.trackedEntity, this.terria.trackedEntity = void 0, this.terria.trackedEntity = e) : this.terria.options.view ? this.setCameraView(this.terria.options.view, this.terria) : "function" == typeof t.flyHome ? t.flyHome(1) : t.flyTo({ destination: Camera.DEFAULT_VIEW_RECTANGLE, duration: 1 }), this.isActive = !1) }, ResetViewNavigationControl.prototype.activate = function () { this.resetView() }, ResetViewNavigationControl.prototype.setCameraView = function (t, e) { var i, e = e || window.viewer; t && (i = t.destination || Cesium.Cartesian3.fromDegrees(t.x, t.y, t.z), e.camera.flyTo({ destination: i, orientation: { heading: Cesium.Math.toRadians(t.heading || 0), pitch: Cesium.Math.toRadians(t.pitch || 0), roll: Cesium.Math.toRadians(t.roll || 0) }, duration: void 0 === t.duration ? 3 : t.duration, complete: t.complete })) }; let cesium$6 = require("cesium/Cesium.js"), { defined: defined$3, Ray, Cartesian3, Cartographic: Cartographic$1, ReferenceFrame, SceneMode } = cesium$6; var Utils = {}, unprojectedScratch = new Cartographic$1, rayScratch = new Ray; Utils.getCameraFocus = function (t, e, i) { var o = t.scene, s = o.camera; if (o.mode !== SceneMode.MORPHING && (defined$3(i) || (i = new Cartesian3), i = defined$3(t.trackedEntity) ? t.trackedEntity.position.getValue(t.clock.currentTime, i) : (rayScratch.origin = s.positionWC, rayScratch.direction = s.directionWC, o.globe.pick(rayScratch, o, i)), defined$3(i))) return o.mode === SceneMode.SCENE2D || o.mode === SceneMode.COLUMBUS_VIEW ? (i = s.worldToCameraCoordinatesPoint(i, i), e && (i = o.globe.ellipsoid.cartographicToCartesian(o.mapProjection.unproject(i, unprojectedScratch), i))) : e || (i = s.worldToCameraCoordinatesPoint(i, i)), i }; let cesium$7 = require("cesium/Cesium.js"), { defined: defined$4, Ray: Ray$1, IntersectionTests, Cartesian3: Cartesian3$1, SceneMode: SceneMode$1 } = cesium$7; var ZoomNavigationControl = function (t, e) { NavigationControl.apply(this, arguments), this.name = "视图 " + (e ? "放大" : "缩小"), this.text = e ? "+" : "-", this.cssClass = "navigation-control-icon-zoom-" + (e ? "in" : "out"), this.relativeAmount = 2, e && (this.relativeAmount = 1 / this.relativeAmount) }, cartesian3Scratch = (ZoomNavigationControl.prototype.relativeAmount = 1, ZoomNavigationControl.prototype = Object.create(NavigationControl.prototype), ZoomNavigationControl.prototype.activate = function () { this.zoom(this.relativeAmount) }, new Cartesian3$1), svgCompassOuterRing = (ZoomNavigationControl.prototype.zoom = function (t) { if (this.isActive = !0, defined$4(this.terria)) { var e = this.terria.scene, i = e.screenSpaceCameraController; if (!i.enableInputs || !i.enableZoom) return; var o = e.camera; switch (e.mode) { case SceneMode$1.MORPHING: break; case SceneMode$1.SCENE2D: o.zoomIn(o.positionCartographic.height * (1 - this.relativeAmount)); break; default: s = defined$4(this.terria.trackedEntity) ? new Cartesian3$1 : Utils.getCameraFocus(this.terria, !1), n = defined$4(s) ? { direction: o.direction, up: o.up } : (n = new Ray$1(o.worldToCameraCoordinatesPoint(e.globe.ellipsoid.cartographicToCartesian(o.positionCartographic)), o.directionWC), s = IntersectionTests.grazingAltitudeLocation(n, e.globe.ellipsoid), { heading: o.heading, pitch: o.pitch, roll: o.roll }); var s, n, r = Cartesian3$1.subtract(o.position, s, cartesian3Scratch), r = Cartesian3$1.multiplyByScalar(r, t, r), r = Cartesian3$1.add(s, r, s); defined$4(this.terria.trackedEntity) || e.mode === SceneMode$1.COLUMBUS_VIEW ? o.position = r : o.flyTo({ destination: r, orientation: n, duration: .5, convert: !1 }) } } this.isActive = !1 }, "m 66.5625,0 0,15.15625 3.71875,0 0,-10.40625 5.5,10.40625 4.375,0 0,-15.15625 -3.71875,0 0,10.40625 L 70.9375,0 66.5625,0 z M 72.5,20.21875 c -28.867432,0 -52.28125,23.407738 -52.28125,52.28125 0,28.87351 23.413818,52.3125 52.28125,52.3125 28.86743,0 52.28125,-23.43899 52.28125,-52.3125 0,-28.873512 -23.41382,-52.28125 -52.28125,-52.28125 z m 0,1.75 c 13.842515,0 26.368948,5.558092 35.5,14.5625 l -11.03125,11 0.625,0.625 11.03125,-11 c 8.9199,9.108762 14.4375,21.579143 14.4375,35.34375 0,13.764606 -5.5176,26.22729 -14.4375,35.34375 l -11.03125,-11 -0.625,0.625 11.03125,11 c -9.130866,9.01087 -21.658601,14.59375 -35.5,14.59375 -13.801622,0 -26.321058,-5.53481 -35.4375,-14.5 l 11.125,-11.09375 c 6.277989,6.12179 14.857796,9.90625 24.3125,9.90625 19.241896,0 34.875,-15.629154 34.875,-34.875 0,-19.245847 -15.633104,-34.84375 -34.875,-34.84375 -9.454704,0 -18.034511,3.760884 -24.3125,9.875 L 37.0625,36.4375 C 46.179178,27.478444 58.696991,21.96875 72.5,21.96875 z m -0.875,0.84375 0,13.9375 1.75,0 0,-13.9375 -1.75,0 z M 36.46875,37.0625 47.5625,48.15625 C 41.429794,54.436565 37.65625,63.027539 37.65625,72.5 c 0,9.472461 3.773544,18.055746 9.90625,24.34375 L 36.46875,107.9375 c -8.96721,-9.1247 -14.5,-21.624886 -14.5,-35.4375 0,-13.812615 5.53279,-26.320526 14.5,-35.4375 z M 72.5,39.40625 c 18.297686,0 33.125,14.791695 33.125,33.09375 0,18.302054 -14.827314,33.125 -33.125,33.125 -18.297687,0 -33.09375,-14.822946 -33.09375,-33.125 0,-18.302056 14.796063,-33.09375 33.09375,-33.09375 z M 22.84375,71.625 l 0,1.75 13.96875,0 0,-1.75 -13.96875,0 z m 85.5625,0 0,1.75 14,0 0,-1.75 -14,0 z M 71.75,108.25 l 0,13.9375 1.71875,0 0,-13.9375 -1.71875,0 z"), svgCompassGyro = "m 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z", svgCompassRotationMarker = "M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z"; let cesium$8 = require("cesium/Cesium.js"), { defined: defined$5, Math: Math$2, getTimestamp: getTimestamp$1, EventHelper: EventHelper$1, Transforms, SceneMode: SceneMode$2, Cartesian2: Cartesian2$1, Cartesian3: Cartesian3$2, Matrix4, BoundingSphere, HeadingPitchRange, knockout: knockout$4 } = cesium$8; var Knockout$4 = knockout$4, NavigationViewModel = function (t) { this.terria = t.terria, this.eventHelper = new EventHelper$1, this.enableZoomControls = !defined$5(t.enableZoomControls) || t.enableZoomControls, this.enableCompass = !defined$5(t.enableCompass) || t.enableCompass, this.navigationLocked = !1, this.controls = t.controls, defined$5(this.controls) || (this.controls = [new ZoomNavigationControl(this.terria, !0), new ResetViewNavigationControl(this.terria), new ZoomNavigationControl(this.terria, !1)]), this.svgCompassOuterRing = svgCompassOuterRing, this.svgCompassGyro = svgCompassGyro, this.svgCompassRotationMarker = svgCompassRotationMarker, this.showCompass = defined$5(this.terria) && this.enableCompass, this.heading = this.showCompass ? this.terria.scene.camera.heading : 0, this.isOrbiting = !1, this.orbitCursorAngle = 0, this.orbitCursorOpacity = 0, this.orbitLastTimestamp = 0, this.orbitFrame = void 0, this.orbitIsLook = !1, this.orbitMouseMoveFunction = void 0, this.orbitMouseUpFunction = void 0, this.isRotating = !1, this.rotateInitialCursorAngle = void 0, this.rotateFrame = void 0, this.rotateIsLook = !1, this.rotateMouseMoveFunction = void 0, this.rotateMouseUpFunction = void 0, this._unsubcribeFromPostRender = void 0, Knockout$4.track(this, ["controls", "showCompass", "heading", "isOrbiting", "orbitCursorAngle", "isRotating"]); var e = this; function i() { defined$5(e.terria) ? (e._unsubcribeFromPostRender && (e._unsubcribeFromPostRender(), e._unsubcribeFromPostRender = void 0), e.showCompass = e.enableCompass, e._unsubcribeFromPostRender = e.terria.scene.postRender.addEventListener(function () { e.heading = e.terria.scene.camera.heading })) : (e._unsubcribeFromPostRender && (e._unsubcribeFromPostRender(), e._unsubcribeFromPostRender = void 0), e.showCompass = !1) } NavigationViewModel.prototype.setNavigationLocked = function (t) { this.navigationLocked = t, this.controls && 1 < this.controls.length && this.controls[1].setNavigationLocked(this.navigationLocked) }, this.eventHelper.add(this.terria.afterWidgetChanged, i, this), i() }, vectorScratch = (NavigationViewModel.prototype.destroy = function () { this.eventHelper.removeAll() }, NavigationViewModel.prototype.show = function (t) { var e = null == this.enableCompass || this.enableCompass, i = null == this.enableZoomControls || this.enableZoomControls; loadView('<div class="compass" id="easy3d-compass" title="" style="display:' + (e ? "block" : "none") + '" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }"><div class="compass-outer-ring-background"></div> <div class="compass-rotation-marker" data-bind="visible: isOrbiting, style: { transform: \'rotate(-\' + orbitCursorAngle + \'rad)\', \'-webkit-transform\': \'rotate(-\' + orbitCursorAngle + \'rad)\', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }"></div> <div class="compass-outer-ring" title="" data-bind="style: { transform: \'rotate(-\' + heading + \'rad)\', \'-webkit-transform\': \'rotate(-\' + heading + \'rad)\' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }"></div> <div class="compass-gyro-background"></div> <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div></div><div class="navigation-controls" id="easy3d-navigation-controls" style="display:' + (i ? "block" : "none") + "\">\x3c!-- ko foreach: controls --\x3e<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">   \x3c!-- ko if: $data.hasText --\x3e   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>   \x3c!-- /ko --\x3e  \x3c!-- ko ifnot: $data.hasText --\x3e  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>  \x3c!-- /ko --\x3e </div> \x3c!-- /ko --\x3e</div>", t, this) }, NavigationViewModel.prototype.setStyle = function (i) { if (i && !(Object.keys(i).length < 1)) { let t = document.getElementById("easy3d-compass"), e = document.getElementById("easy3d-navigation-controls"); if (t) for (var o in i) t.style[o] = i[o], e.style[o] = i[o], "top" == o && (e.style[o] = parseFloat(i[o]) + 100 + "px"), "bottom" == o && (t.style[o] = parseFloat(i[o]) + 82 + "px"), "left" == o && (e.style.left = parseFloat(t.style.left) + 30 + "px"), "right" == o && (e.style.right = parseFloat(t.style.right) - 30 + "px") } }, NavigationViewModel.prototype.add = function (t) { this.controls.push(t) }, NavigationViewModel.prototype.remove = function (t) { this.controls.remove(t) }, NavigationViewModel.prototype.isLastControl = function (t) { return t === this.controls[this.controls.length - 1] }, new Cartesian2$1), oldTransformScratch = (NavigationViewModel.prototype.handleMouseDown = function (t, e) { if (this.terria.scene.mode === SceneMode$2.MORPHING) return !0; if (t.navigationLocked) return !0; var t = e.currentTarget, i = e.currentTarget.getBoundingClientRect(), o = i.width / 2, s = new Cartesian2$1((i.right - i.left) / 2, (i.bottom - i.top) / 2), e = new Cartesian2$1(e.clientX - i.left, e.clientY - i.top), i = Cartesian2$1.subtract(e, s, vectorScratch), e = Cartesian2$1.magnitude(i) / o; if (e < 50 / 145) orbit(this, t, i); else { if (!(e < 1)) return !0; rotate(this, t, i) } }, new Matrix4), newTransformScratch = new Matrix4, centerScratch = new Cartesian3$2; function orbit(r, o, t) { var a = r.terria.scene, e = a.screenSpaceCameraController; if (a.mode !== SceneMode$2.MORPHING && e.enableInputs) { if (r.navigationLocked) return !0; switch (a.mode) { case SceneMode$2.COLUMBUS_VIEW: if (e.enableLook) break; if (e.enableTranslate && e.enableTilt) break; return; case SceneMode$2.SCENE3D: if (e.enableLook) break; if (e.enableTilt && e.enableRotate) break; return; case SceneMode$2.SCENE2D: if (e.enableTranslate) break; return }document.removeEventListener("mousemove", r.orbitMouseMoveFunction, !1), document.removeEventListener("mouseup", r.orbitMouseUpFunction, !1), defined$5(r.orbitTickFunction) && r.terria.clock.onTick.removeEventListener(r.orbitTickFunction), r.orbitMouseMoveFunction = void 0, r.orbitMouseUpFunction = void 0, r.orbitTickFunction = void 0, r.isOrbiting = !0, r.orbitLastTimestamp = getTimestamp$1(); var i, l = a.camera; defined$5(r.terria.trackedEntity) ? (r.orbitFrame = void 0, r.orbitIsLook = !1) : (i = Utils.getCameraFocus(r.terria, !0, centerScratch), defined$5(i) ? (r.orbitFrame = Transforms.eastNorthUpToFixedFrame(i, a.globe.ellipsoid, newTransformScratch), r.orbitIsLook = !1) : (r.orbitFrame = Transforms.eastNorthUpToFixedFrame(l.positionWC, a.globe.ellipsoid, newTransformScratch), r.orbitIsLook = !0)), r.orbitTickFunction = function (t) { var e, i = getTimestamp$1(), o = (i - r.orbitLastTimestamp) * (2.5 * (r.orbitCursorOpacity - .5) / 1e3), s = r.orbitCursorAngle + Math$2.PI_OVER_TWO, n = Math$2.cos(s) * o, s = Math$2.sin(s) * o; if (r.navigationLocked) return !0; defined$5(r.orbitFrame) && (e = Matrix4.clone(l.transform, oldTransformScratch), l.lookAtTransform(r.orbitFrame)), a.mode === SceneMode$2.SCENE2D ? l.move(new Cartesian3$2(n, s, 0), Math$2.max(a.canvas.clientWidth, a.canvas.clientHeight) / 100 * l.positionCartographic.height * o) : r.orbitIsLook ? (l.look(Cartesian3$2.UNIT_Z, -n), l.look(l.right, -s)) : (l.rotateLeft(n), l.rotateUp(s)), defined$5(r.orbitFrame) && l.lookAtTransform(e), r.orbitLastTimestamp = i }, r.orbitMouseMoveFunction = function (t) { var e = o.getBoundingClientRect(), i = new Cartesian2$1((e.right - e.left) / 2, (e.bottom - e.top) / 2), t = new Cartesian2$1(t.clientX - e.left, t.clientY - e.top); s(Cartesian2$1.subtract(t, i, vectorScratch), e.width) }, r.orbitMouseUpFunction = function (t) { r.isOrbiting = !1, document.removeEventListener("mousemove", r.orbitMouseMoveFunction, !1), document.removeEventListener("mouseup", r.orbitMouseUpFunction, !1), defined$5(r.orbitTickFunction) && r.terria.clock.onTick.removeEventListener(r.orbitTickFunction), r.orbitMouseMoveFunction = void 0, r.orbitMouseUpFunction = void 0, r.orbitTickFunction = void 0 }, document.addEventListener("mousemove", r.orbitMouseMoveFunction, !1), document.addEventListener("mouseup", r.orbitMouseUpFunction, !1), r.terria.clock.onTick.addEventListener(r.orbitTickFunction), s(t, o.getBoundingClientRect().width) } function s(t, e) { var i = Math$2.atan2(-t.y, t.x), i = (r.orbitCursorAngle = Math$2.zeroToTwoPi(i - Math$2.PI_OVER_TWO), Cartesian2$1.magnitude(t)), t = e / 2, e = Math$2.min(i / t, 1); r.orbitCursorOpacity = .5 * e * e + .5 } } function rotate(s, n, t) { var e, i = s.terria.scene, o = i.camera, r = i.screenSpaceCameraController; if (i.mode !== SceneMode$2.MORPHING && i.mode !== SceneMode$2.SCENE2D && r.enableInputs) { if (s.navigationLocked) return !0; (r.enableLook || i.mode !== SceneMode$2.COLUMBUS_VIEW && (i.mode !== SceneMode$2.SCENE3D || r.enableRotate)) && (document.removeEventListener("mousemove", s.rotateMouseMoveFunction, !1), document.removeEventListener("mouseup", s.rotateMouseUpFunction, !1), s.rotateMouseMoveFunction = void 0, s.rotateMouseUpFunction = void 0, s.isRotating = !0, s.rotateInitialCursorAngle = Math$2.atan2(-t.y, t.x), defined$5(s.terria.trackedEntity) ? (s.rotateFrame = void 0, s.rotateIsLook = !1) : (t = Utils.getCameraFocus(s.terria, !0, centerScratch), defined$5(t) && (i.mode !== SceneMode$2.COLUMBUS_VIEW || r.enableLook || r.enableTranslate) ? (s.rotateFrame = Transforms.eastNorthUpToFixedFrame(t, i.globe.ellipsoid, newTransformScratch), s.rotateIsLook = !1) : (s.rotateFrame = Transforms.eastNorthUpToFixedFrame(o.positionWC, i.globe.ellipsoid, newTransformScratch), s.rotateIsLook = !0)), defined$5(s.rotateFrame) && (e = Matrix4.clone(o.transform, oldTransformScratch), o.lookAtTransform(s.rotateFrame)), s.rotateInitialCameraAngle = -o.heading, defined$5(s.rotateFrame) && o.lookAtTransform(e), s.rotateMouseMoveFunction = function (t) { var e, i = n.getBoundingClientRect(), o = new Cartesian2$1((i.right - i.left) / 2, (i.bottom - i.top) / 2), t = new Cartesian2$1(t.clientX - i.left, t.clientY - i.top), i = Cartesian2$1.subtract(t, o, vectorScratch), t = Math$2.atan2(-i.y, i.x) - s.rotateInitialCursorAngle, o = Math$2.zeroToTwoPi(s.rotateInitialCameraAngle - t), i = s.terria.scene.camera, t = (defined$5(s.rotateFrame) && (e = Matrix4.clone(i.transform, oldTransformScratch), i.lookAtTransform(s.rotateFrame)), -i.heading); i.rotateRight(o - t), defined$5(s.rotateFrame) && i.lookAtTransform(e) }, s.rotateMouseUpFunction = function (t) { s.isRotating = !1, document.removeEventListener("mousemove", s.rotateMouseMoveFunction, !1), document.removeEventListener("mouseup", s.rotateMouseUpFunction, !1), s.rotateMouseMoveFunction = void 0, s.rotateMouseUpFunction = void 0 }, document.addEventListener("mousemove", s.rotateMouseMoveFunction, !1), document.addEventListener("mouseup", s.rotateMouseUpFunction, !1)) } } NavigationViewModel.prototype.handleDoubleClick = function (t, e) { var i = t.terria.scene, o = i.camera, s = i.screenSpaceCameraController; if (i.mode === SceneMode$2.MORPHING || !s.enableInputs) return !0; if (t.navigationLocked) return !0; if (i.mode !== SceneMode$2.COLUMBUS_VIEW || s.enableTranslate) { if (i.mode === SceneMode$2.SCENE3D || i.mode === SceneMode$2.COLUMBUS_VIEW) { if (!s.enableLook) return; if (i.mode === SceneMode$2.SCENE3D && !s.enableRotate) return } var n, s = Utils.getCameraFocus(t.terria, !0, centerScratch); defined$5(s) ? (t = i.globe.ellipsoid.cartographicToCartesian(o.positionCartographic, new Cartesian3$2), i = i.globe.ellipsoid.geodeticSurfaceNormal(s), n = new BoundingSphere(s, 0), o.flyToBoundingSphere(n, { offset: new HeadingPitchRange(0, Math$2.PI_OVER_TWO - Cartesian3$2.angleBetween(i, o.directionWC), Cartesian3$2.distance(t, s)), duration: 1.5 })) : this.controls[1].resetView() } }, NavigationViewModel.create = function (t) { var e = new NavigationViewModel(t); return e.show(t.container), e.setStyle(t.style), e }; let cesium$9 = require("cesium/Cesium.js"), { defined: defined$6, Event, knockout: knockout$5, DeveloperError: DeveloperError$2 } = cesium$9; var CesiumEvent = Event, CesiumNavigation = function (t) { initialize.apply(this, arguments), this._onDestroyListeners = [] }; function initialize(t, e) { if (!defined$6(t)) throw new DeveloperError$2("CesiumWidget or Viewer is required."); var i = defined$6(t.cesiumWidget) ? t.cesiumWidget : t, o = document.createElement("div"); o.className = "cesium-widget-cesiumNavigationContainer", i.container.appendChild(o), this.container = o, this.terria = t, this.terria.options = defined$6(e) ? e : {}, this.terria.afterWidgetChanged = new CesiumEvent, this.terria.beforeWidgetChanged = new CesiumEvent, this.distanceLegendDiv = document.createElement("div"), o.appendChild(this.distanceLegendDiv), this.distanceLegendDiv.setAttribute("id", "distanceLegendDiv"); let s = e.distanceLegend && e.distanceLegend.style || "leftBottom", n = (s = "string" == typeof s ? getDistanceStyleByType(s) : s, this.distanceLegendViewModel = DistanceLegendViewModel.create({ container: this.distanceLegendDiv, style: s, terria: this.terria, enableDistanceLegend: null == this.terria.options.enableDistanceLegend || this.terria.options.enableDistanceLegend }), this.navigationDiv = document.createElement("div"), this.navigationDiv.setAttribute("id", "navigationDiv"), o.appendChild(this.navigationDiv), e.distanceLegend && e.distanceLegend.style || "leftBottom"); n = "string" == typeof n ? getCompassStyleByType(n) : n, this.navigationViewModel = NavigationViewModel.create({ container: this.navigationDiv, terria: this.terria, style: n, enableZoomControls: null == this.terria.options.enableZoomControls || this.terria.options.enableZoomControls, enableCompass: null == this.terria.options.enableCompass || this.terria.options.enableCompass }), registerKnockoutBindings() } function getDistanceStyleByType(t) { t = t || "leftBottom"; let e = {}; return (e = "leftBottom" == t ? { left: "10px", bottom: "4px" } : "leftTop" == t ? { left: "20px", top: "20px" } : "rightBottom" == t ? { right: "20px", bottom: "4px" } : { right: "20px", top: "20px" }).zIndex = 99999, e } function getCompassStyleByType(t) { t = t || "rightTop"; let e = {}; return (e = "leftBottom" == t ? { left: "20px", bottom: "60px" } : "leftTop" == t ? { left: "20px", top: "20px" } : "rightBottom" == t ? { right: "20px", bottom: "60px" } : { right: "20px", top: "20px" }).zIndex = 99999, e } CesiumNavigation.prototype.distanceLegendViewModel = void 0, CesiumNavigation.prototype.navigationViewModel = void 0, CesiumNavigation.prototype.navigationDiv = void 0, CesiumNavigation.prototype.distanceLegendDiv = void 0, CesiumNavigation.prototype.terria = void 0, CesiumNavigation.prototype.container = void 0, CesiumNavigation.prototype._onDestroyListeners = void 0, CesiumNavigation.prototype._navigationLocked = !1, CesiumNavigation.prototype.setNavigationLocked = function (t) { this._navigationLocked = t, this.navigationViewModel.setNavigationLocked(this._navigationLocked) }, CesiumNavigation.prototype.getNavigationLocked = function () { return this._navigationLocked }, CesiumNavigation.prototype.destroy = function () { defined$6(this.navigationViewModel) && this.navigationViewModel.destroy(), defined$6(this.distanceLegendViewModel) && this.distanceLegendViewModel.destroy(), defined$6(this.navigationDiv) && this.navigationDiv.parentNode.removeChild(this.navigationDiv), delete this.navigationDiv, defined$6(this.distanceLegendDiv) && this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv), delete this.distanceLegendDiv, defined$6(this.container) && this.container.parentNode.removeChild(this.container), delete this.container; for (var t = 0; t < this._onDestroyListeners.length; t++)this._onDestroyListeners[t]() }, CesiumNavigation.prototype.addOnDestroyListener = function (t) { "function" == typeof t && this._onDestroyListeners.push(t) }; let easy3dView = { viewAround: { initView: null, removeEventHdl: null, startTime: null, isStop: !1, initHeading: null, start: function (t) { viewer.clock.shouldAnimate = !0, this.isStop = !1, this.initView = t || cUtil.getCameraView(), this.initHeading = this.initView.heading, this.startTime = viewer.clock.currentTime; var e = this; this.removeEventHdl || (this.removeEventHdl = viewer.clock.onTick.addEventListener(function () { var t; e.isStop || (t = Cesium.JulianDate.secondsDifference(viewer.clock.currentTime, e.startTime), e.initView.heading = e.initHeading + t * e.angle, e.initView.duration = 0, cUtil.setCameraView(e.initView)) })) }, end: function () { this.removeEventHdl && (this.removeEventHdl(), this.removeEventHdl = null), this.initView = null, this.startTime = null, this.isStop = !1, this.initHeading = null, this.angle = 5 }, stop: function () { this.isStop = !0 }, goon: function () { this.initView = cUtil.getCameraView(), this.startTime = viewer.clock.startTime, this.initHeading = this.initView.heading, this.isStop = !1 }, angle: 5, setSpeed: function (t) { this.angle = t } }, viewPoint: { removeEventLis: null, initHeading: 0, isStop: !1, position: null, startTime: null, start: function (e) { viewer.clock.shouldAnimate = !0, e || (t = cUtil.getViewCenter(), e = Cesium.Cartesian3.fromDegrees(t[0], t[1])), this.position = e, this.startTime = viewer.clock.currentTime, this.isStop = !1; var t, i = this; this.removeEventLis || (this.removeEventLis = viewer.clock.onTick.addEventListener(function () { var t; i.isStop || (t = Cesium.JulianDate.secondsDifference(viewer.clock.currentTime, i.startTime), t = i.initHeading + t * i.angle, t = i.setHpr({ heading: t }), viewer.camera.lookAt(e, t)) })) }, stop: function () { this.isStop = !0 }, goon: function () { this.startTime = viewer.clock.startTime, this.isStop = !1 }, end: function () { this.removeEventLis && (this.removeEventLis(), this.removeEventLis = null), this.initHeading = 0, this.isStop = !1, this.position = null, this.startTime = null, this.angle = 5 }, angle: 5, setSpeed: function (t) { this.angle = t }, setHpr: function (t) { var e = Cesium.Math.toRadians(t.heading || 0), i = Cesium.Math.toRadians(t.pitch || -60), t = t.range || 5e3; return new Cesium.HeadingPitchRange(e, i, t) }, setPosotion: function (t) { this.position = t } }, setRotate(t, e) { var i, o, s, n, r, a, l; t.x && t.y ? (i = t.v || 1, o = 0, s = t.q || 2, n = t.x, r = t.y, a = t.z, l = window.setInterval(function () { 179 <= (n += i) && (n = -180, o++), viewer.scene.camera.setView({ destination: new Cesium.Cartesian3.fromDegrees(n, r, a || 2e7) }), o == s && (clearInterval(l), e()) }, 16)) : console.log("设定地球旋转时，并未传入经纬度！") } }; var fog = { fogProcs: null, isActivate: !1, fogVal: .5, activate: function () { var t; this.isActivate || (this.isActivate = !0, t = this.initfog(), this.fogProcs = new Cesium.PostProcessStage({ name: "czm_fog", fragmentShader: t }), viewer.scene.postProcessStages.add(this.fogProcs)) }, disable: function () { this.isActivate && (this.isActivate = !1, this.fogProcs && (viewer.scene.postProcessStages.remove(this.fogProcs), this.fogProcs.destroy(), this.fogProcs = null)) }, initfog: function () { return "  uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  varying vec2 v_textureCoordinates;\n  void main(void)\n  {\n      vec4 origcolor=texture2D(colorTexture, v_textureCoordinates);\n      vec4 fogcolor=vec4(0.8,0.8,0.8,0.2);\n\n      vec4 depthcolor = texture2D(depthTexture, v_textureCoordinates);\n\n      float f=(depthcolor.r-0.22)/" + this.fogVal + ";\n      if(f<0.0) f=0.0;\n      else if(f>1.0) f=1.0;\n      gl_FragColor = mix(origcolor,fogcolor,f);\n   }" } }, rain = { rainProcs: null, isActivate: !1, activate: function () { var t; this.isActivate || (this.isActivate = !0, t = this.initRain(), this.rainProcs = new Cesium.PostProcessStage({ name: "czm_rain", fragmentShader: t }), viewer.scene.postProcessStages.add(this.rainProcs)) }, disable: function () { this.isActivate && (this.isActivate = !1, this.rainProcs && (viewer.scene.postProcessStages.remove(this.rainProcs), this.rainProcs = null)) }, initRain: function () { return "uniform sampler2D colorTexture;\n                varying vec2 v_textureCoordinates;\n                \n                float hash(float x){\n                    return fract(sin(x*23.3)*13.13);\n                }\n                \n                void main(void){\n                \n                    float time = czm_frameNumber / 60.0;\n                    vec2 resolution = czm_viewport.zw;\n                    \n                    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n                    vec3 c=vec3(.6,.7,.8);\n                    \n                    float a=-.4;\n                    float si=sin(a),co=cos(a);\n                    uv*=mat2(co,-si,si,co);\n                    uv*=length(uv+vec2(0,4.9))*.3+1.;\n                    \n                    float v=1.-sin(hash(floor(uv.x*100.))*2.);\n                    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n                    c*=v*b; \n                    \n                    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5);  \n                }\n        " } }, snow = { snowProcs: null, isActivate: !1, activate: function () { var t; this.isActivate || (this.isActivate = !0, t = this.initSnow(), this.snowProcs = new Cesium.PostProcessStage({ name: "czm_snow", fragmentShader: t }), viewer.scene.postProcessStages.add(this.snowProcs)) }, disable: function () { this.isActivate && (this.isActivate = !1, this.snowProcs && (viewer.scene.postProcessStages.remove(this.snowProcs), this.snowProcs = null)) }, initSnow: function () { return "uniform sampler2D colorTexture;\n                varying vec2 v_textureCoordinates;\n                \n                float snow(vec2 uv,float scale)\n                {\n                float time = czm_frameNumber / 60.0;\n                float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n                uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\n                uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n                p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n                k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n                return k*w;\n                }\n                \n                void main(void){\n                vec2 resolution = czm_viewport.zw;\n                vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n                vec3 finalColor=vec3(0);\n                float c = 0.0;\n                c+=snow(uv,30.)*.0;\n                c+=snow(uv,20.)*.0;\n                c+=snow(uv,15.)*.0;\n                c+=snow(uv,10.);\n                c+=snow(uv,8.);\n                c+=snow(uv,6.);\n                c+=snow(uv,5.);\n                finalColor=(vec3(c)); \n                gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.3); \n                \n                }\n            " } }; function getPostStageFragmentShader(t, e) { var i = t._usesDepthTexture, o = t._polygonOffsetSupported, s = t._isPointLight, n = t._isSpotLight, r = 1 < t._numberOfCascades, a = t.debugCascadeColors, l = "", l = (s ? l += "#define USE_CUBE_MAP_SHADOW\n" : i && (l += "#define USE_SHADOW_DEPTH_TEXTURE\n"), t.softShadows && !s && (l += "#define USE_SOFT_SHADOWS\n"), (l = (l += "uniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\n") + (s ? "uniform samplerCube shadowMap_textureCube; \n" : "uniform sampler2D shadowMap_texture; \n") + "uniform mat4 shadowMap_matrix; \nuniform vec3 shadowMap_lightDirectionEC; \nuniform vec4 shadowMap_lightPositionEC; \nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \nuniform vec4 viewShed_frontColor; \nuniform vec4 viewShed_backColor; \nuniform float viewShed_Fov; \nuniform float viewShed_Far;\n\nvarying vec2 v_textureCoordinates;\n\nstruct sg_shadowParameters\n{\n#ifdef USE_CUBE_MAP_SHADOW\n    vec3 texCoords;\n#else\n    vec2 texCoords;\n#endif\n\n    float depthBias;\n    float depth;\n    float nDotL;\n    vec2 texelStepSize;\n    float normalShadingSmooth;\n    float darkness;\n};\n#ifdef USE_CUBE_MAP_SHADOW\nfloat sg_sampleShadowMap(samplerCube shadowMap, vec3 d)\n{\n    return czm_unpackDepth(textureCube(shadowMap, d));\n}\nfloat sg_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\n{\n    return step(depth, sg_sampleShadowMap(shadowMap, uv));\n}\nfloat sg_shadowVisibility(samplerCube shadowMap, sg_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec3 uvw = shadowParameters.texCoords;\n\n    depth -= depthBias;\n    float visibility = sg_shadowDepthCompare(shadowMap, uvw, depth);\n    return visibility;\n}\n#else\nfloat sg_sampleShadowMap(sampler2D shadowMap, vec2 uv)\n{\n#ifdef USE_SHADOW_DEPTH_TEXTURE\n    return texture2D(shadowMap, uv).r;\n#else\n    return czm_unpackDepth(texture2D(shadowMap, uv));\n#endif\n}\nfloat sg_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\n{\n    return step(depth, sg_sampleShadowMap(shadowMap, uv));\n}\nfloat sg_shadowVisibility(sampler2D shadowMap, sg_shadowParameters shadowParameters)\n{\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n\n    depth -= depthBias;\n#ifdef USE_SOFT_SHADOWS\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility = (\n        sg_shadowDepthCompare(shadowMap, uv, depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n        sg_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0);\n#else\n    float visibility = sg_shadowDepthCompare(shadowMap, uv, depth);\n#endif\n\n    return visibility;\n}\n#endif\nvec4 getPositionEC(float depth) \n{ \n    vec2 xy = vec2((v_textureCoordinates.x * 2.0 - 1.0), (v_textureCoordinates.y * 2.0 - 1.0));\n    float z = (depth - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 posInCamera = czm_inverseProjection * vec4(xy, z, 1.0);\n    posInCamera = posInCamera / posInCamera.w;\n    return posInCamera;\n} \nvec3 getNormalEC() \n{ \n    return vec3(1.0); \n} \n\n") + "void main() \n{ \n    float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n    if(depth > 0.999999)\n    {\n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return;\n    }\n    vec4 positionEC = getPositionEC(depth); \n    vec3 normalEC = getNormalEC(); \n    float z = -positionEC.z; \n" + "    sg_shadowParameters shadowParameters; \n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \n"); return e ? l += "    shadowParameters.depthBias *= max(z * 0.01, 1.0); \n" : o || (l += "    shadowParameters.depthBias *= mix(1.0, 100.0, z * 0.0015); \n"), l = l + (s ? "    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    directionEC = normalize(directionEC); \n    float radius = shadowMap_lightPositionEC.w; \n    // Stop early if the fragment is beyond the point light radius \n    if (distance > radius) \n    { \n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return; \n    } \n    vec3 directionWC  = czm_inverseViewRotation * directionEC; \n    shadowParameters.depth = distance / radius; \n    shadowParameters.texCoords = directionWC; \n    float visibility = sg_shadowVisibility(shadowMap_textureCube, shadowParameters); \n" : n ? "    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \n    float distance = length(directionEC); \n    if(distance > viewShed_Far)\n    {\n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return;\n    }\n    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Spot light uses a perspective projection, so perform the perspective divide \n    shadowPosition /= shadowPosition.w; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    float visibility = sg_shadowVisibility(shadowMap_texture, shadowParameters); \n" : r ? "    float maxDepth = shadowMap_cascadeSplits[1].w; \n    // Stop early if the eye depth exceeds the last cascade \n    if (z > maxDepth) \n    { \n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return; \n    } \n    // Get the cascade based on the eye-space z \n    vec4 weights = czm_cascadeWeights(z); \n    // Transform position into the cascade \n    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \n    // Get visibility \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    float visibility = sg_shadowVisibility(shadowMap_texture, shadowParameters); \n    // Fade out shadows that are far away \n    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \n    float fade = max((z - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \n    visibility = mix(visibility, 1.0, fade); \n" : "    vec4 shadowPosition = shadowMap_matrix * positionEC; \n    // Stop early if the fragment is not in the shadow bounds \n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \n    { \n        gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n        return; \n    } \n    shadowParameters.texCoords = shadowPosition.xy; \n    shadowParameters.depth = shadowPosition.z; \n    float visibility = sg_shadowVisibility(shadowMap_texture, shadowParameters); \n") + ("    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n" + (r && a ? "    color *= czm_cascadeColor(weights); \n" : "") + "    if(visibility > 0.0) \n        gl_FragColor = vec4(color.rgb * (1.0 - viewShed_frontColor.a) + viewShed_frontColor.rgb * viewShed_frontColor.a, color.a); \n    else \n        gl_FragColor = vec4(color.rgb * (1.0 - viewShed_backColor.a) + viewShed_backColor.rgb * viewShed_backColor.a, color.a); \n} \n") } class VisualField { constructor(t, e) { if (!Cesium.defined(t)) throw new Cesium.DeveloperError("缺少地图对象！"); this.options = e || {}, this._scene = t.scene; t = e.cameraOptions || {}; this._enabled = Cesium.defaultValue(e.enabled, !0), this._viewerPosition = Cesium.defaultValue(t.viewerPosition, new Cesium.Cartesian3.fromDegrees(0, 0, 0)), this._heading = Cesium.defaultValue(t.heading, 0), this._pitch = Cesium.defaultValue(t.pitch, 0), this._horizontalFov = Cesium.defaultValue(t.horizontalFov, 179.9), this._verticalFov = Cesium.defaultValue(t.verticalFov, 60), this._distance = Cesium.defaultValue(t.distance, 100), this._visibleAreaColor = t.visibleAreaColor instanceof Cesium.Color ? t.visibleAreaColor : Cesium.Color.fromCssColorString(t.visibleAreaColor), this._visibleAreaColorAlpha = null == t.visibleAreaColorAlpha ? 1 : t.visibleAreaColorAlpha, this._hiddenAreaColor = t.hiddenAreaColor instanceof Cesium.Color ? t.hiddenAreaColor : Cesium.Color.fromCssColorString(t.hiddenAreaColor), this._hiddenAreaColorAlpha = null == t.hiddenAreaColorAlpha ? 1 : t.hiddenAreaColorAlpha, this._size = Cesium.defaultValue(e.size, 2048), this._softShadows = Cesium.defaultValue(e.softShadows, !1), this._bugDistance = this._distance + 1e-6 * this._horizontalFov - 1e-6 * this._verticalFov, this._outlineColor = Cesium.defaultValue(e.outlineColor, Cesium.Color.YELLOW), this._lightCameraPrimitive = void 0, this._lightCamera = new Cesium.Camera(this._scene), this._lightCameraDirty = !1, this._stage = void 0, this._stageDirty = !0, this.updateCamera(), this._shadowMap = new Cesium.ShadowMap({ context: this._scene.context, lightCamera: this._lightCamera, enabled: this._enabled, isPointLight: !1, pointLightRadius: 100, cascadesEnabled: !1, size: this._size, softShadows: this._softShadows, normalOffset: !1, fromLightSource: !1 }), this._bias = this._shadowMap._primitiveBias } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._shadowMap.enabled = t } get softShadows() { return this._softShadows } set softShadows(t) { this._softShadows = t, this._shadowMap.softShadows = t } get size() { return this._size } set size(t) { this.size = t, this._shadowMap.size = t } get visibleAreaColor() { return Cesium.Color.fromCartesian4(this._visibleAreaColor) } set visibleAreaColor(t) { t = t instanceof Cesium.Color ? t : Cesium.Color.fromCssColorString(t); this._visibleAreaColor = t, this._scene.requestRender() } get visibleAreaColorAlpha() { return this._visibleAreaColorAlpha } set visibleAreaColorAlpha(t) { this._visibleAreaColorAlpha = Number(t), this._scene.requestRender() } get hiddenAreaColorAlpha() { return this._hiddenAreaColorAlpha } set hiddenAreaColorAlpha(t) { this._hiddenAreaColorAlpha = Number(t), this._scene.requestRender() } get hiddenAreaColor() { return Cesium.Color.fromCartesian4(this._hiddenAreaColor) } set hiddenAreaColor(t) { t = t instanceof Cesium.Color ? t : Cesium.Color.fromCssColorString(t); this._hiddenAreaColor = t, this._scene.requestRender() } get viewerPosition() { return this._viewerPosition } set viewerPosition(t) { this._viewerPosition = t, this._lightCameraDirty = !0, this._scene.requestRender() } get heading() { return this._heading } set heading(t) { this._heading = t, this._lightCameraDirty = !0, this._scene.requestRender() } get pitch() { return this._pitch } set pitch(t) { this._pitch = t, this._lightCameraDirty = !0, this._scene.requestRender() } get horizontalFov() { return this._horizontalFov } set horizontalFov(t) { this._horizontalFov = t, this._bugDistance = this._distance + 1e-6 * this._horizontalFov - 1e-6 * this._verticalFov, this._lightCameraDirty = !0, this._scene.requestRender() } get verticalFov() { return this._verticalFov } set verticalFov(t) { this._verticalFov = t, this._bugDistance = this._distance + 1e-6 * this._horizontalFov - 1e-6 * this._verticalFov, this._lightCameraDirty = !0, this._scene.requestRender() } get distance() { return this._distance } set distance(t) { this._distance = t, this._bugDistance = this._distance + 1e-6 * this._horizontalFov - 1e-6 * this._verticalFov, this._lightCameraDirty = !0, this._scene.requestRender() } updateCamera() { this._lightCamera.frustum.near = .001 * this._bugDistance, this._lightCamera.frustum.far = this._bugDistance, this._lightCamera.frustum.fov = Cesium.Math.toRadians(this._verticalFov); var t = Cesium.Math.toRadians(this._horizontalFov), e = Cesium.Math.toRadians(this._verticalFov), t = (this._lightCamera.frustum.aspectRatio = this._bugDistance * Math.tan(.5 * t) * 2 / (this._bugDistance * Math.tan(.5 * e) * 2), this._lightCamera.frustum.aspectRatio = Math.tan(.5 * t) / Math.tan(.5 * e), this._horizontalFov > this._verticalFov && (this._lightCamera.frustum.fov = Cesium.Math.toRadians(this._horizontalFov)), this._lightCamera.setView({ destination: this._viewerPosition, orientation: { heading: Cesium.Math.toRadians(this._heading), pitch: Cesium.Math.toRadians(this._pitch) } }), this._lightCameraPrimitive && (this._lightCameraPrimitive.destroy(), this._lightCameraPrimitive = void 0), this.createOutLineGeometry()); this._lightCameraPrimitive = new Cesium.Primitive({ geometryInstances: new Cesium.GeometryInstance({ geometry: t, attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor(this._outlineColor) } }), appearance: new Cesium.PerInstanceColorAppearance({ translucent: !1, flat: !0 }), modelMatrix: this._lightCamera.inverseViewMatrix, asynchronous: !1 }), this._lightCameraDirty = !1 } createOutLineGeometry() { var t = new Float32Array(633); let e, i, o, s = t, n = Cesium.Math.toRadians(this._horizontalFov), r = Cesium.Math.toRadians(this._verticalFov), a = Math.tan(.5 * n), l = Math.tan(.5 * r), h = (i = this._distance * a, o = this._distance * l, e = -i, 0); s[h++] = 0, s[h++] = 0, s[h++] = 0; let c, d; var u = Math.PI - .5 * n; let p = n / 4; for (let t = 0; t < 5; ++t) { c = u + t * p; var m = o / (this._distance / Math.cos(c)), m = Math.atan(m), g = -m, C = m / 10; for (let t = 0; t < 21; ++t)d = g + t * C, s[h++] = this._distance * Math.cos(d) * Math.sin(c), s[h++] = this._distance * Math.sin(d), s[h++] = this._distance * Math.cos(d) * Math.cos(c) } p = n / 20; for (let t = 0; t < 21; ++t) { c = u + t * p; var y = o / (this._distance / Math.cos(c)), y = Math.atan(y), v = -y, f = y / 2; for (let t = 0; t < 5; ++t)d = v + t * f, s[h++] = this._distance * Math.cos(d) * Math.sin(c), s[h++] = this._distance * Math.sin(d), s[h++] = this._distance * Math.cos(d) * Math.cos(c) } var w = new Cesium.GeometryAttributes({ position: new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.DOUBLE, componentsPerAttribute: 3, values: t }) }), b = new Uint16Array(408); let P = b, T = 0; P[T++] = 0, P[T++] = 1, P[T++] = 0, P[T++] = 21, P[T++] = 0, P[T++] = 85, P[T++] = 0, P[T++] = 105; for (let e = 0, t = 0; t < 5; ++t) { e++; for (let t = 0; t < 20; ++t)P[T++] = e++, P[T++] = e } e++; for (let t = 0; t < 20; ++t)for (let t = 0; t < 5; ++t)P[T++] = e, P[T++] = 5 + e++; return new Cesium.Geometry({ attributes: w, indices: b, primitiveType: Cesium.PrimitiveType.LINES, boundingSphere: Cesium.BoundingSphere.fromVertices(t) }) } updateStage() { if (this._stageDirty) { this._stageDirty = !1, Cesium.defined(this._stage) && (this._scene.postProcessStages.remove(this._stage), this._stage = void 0); let e = new Cesium.Cartesian2, i = this._bias, o = this._shadowMap, s = this; var t = { shadowMap_texture: function () { return o._shadowMapTexture }, shadowMap_matrix: function () { return o._shadowMapMatrix }, viewShed_frontColor: function () { var t = s._visibleAreaColor.withAlpha(s._visibleAreaColorAlpha); return Cesium.Cartesian4.fromColor(t) }, viewShed_backColor: function () { var t = s._hiddenAreaColor.withAlpha(s._hiddenAreaColorAlpha); Cesium.Cartesian4.fromColor(t); return s._hiddenAreaColor }, viewShed_Far: function () { return o._lightCamera.frustum.far }, shadowMap_lightheadingEC: function () { return o._lightheadingEC }, shadowMap_lightPositionEC: function () { return o._lightPositionEC }, shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () { let t = e; return t.x = 1 / o._textureSize.x, t.y = 1 / o._textureSize.y, Cesium.Cartesian4.fromElements(t.x, t.y, i.depthBias, i.normalShadingSmooth, this.combinedUniforms1) }, shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () { return Cesium.Cartesian4.fromElements(i.normalOffsetScale, o._distance, o.maximumDistance, o._darkness, this.combinedUniforms2) }, combinedUniforms1: new Cesium.Cartesian4, combinedUniforms2: new Cesium.Cartesian4 }, n = getPostStageFragmentShader(o, !1); this._stage = new Cesium.PostProcessStage({ fragmentShader: n, uniforms: t }), this._scene.postProcessStages.add(this._stage) } } update(t) { this._lightCameraDirty && this.updateCamera(), this.updateStage(), t.shadowMaps.push(this._shadowMap), this._lightCameraPrimitive && this._lightCameraPrimitive.update(t) } destroy() { Cesium.defined(this._stage) && (this._scene.postProcessStages.remove(this._stage), this._stage = void 0), this._shadowMap = this._shadowMap.destroy(), this._lightCameraPrimitive && (this._lightCameraPrimitive.destroy(), this._lightCameraPrimitive = void 0) } } class VisualTool { constructor(t, e) { if (!Cesium.defined(t)) throw new Cesium.DeveloperError("缺少地图对象！"); this.viewer = t, this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas), this.positions = [], this.prompt = null, this.startPosition = null, this.endPosition = null, this.vfPrimitive = null; this.opt = Object.assign({ visibleAreaColor: "#00FF00", visibleAreaColorAlpha: 1, hiddenAreaColor: "#FF0000", hiddenAreaColorAlpha: 1, verticalFov: 60, horizontalFov: 120 }, e || {}), this.visibleAreaColor = this.opt.visibleAreaColor, this.hiddenAreaColor = this.opt.hiddenAreaColor, this.visibleAreaColorAlpha = this.opt.visibleAreaColorAlpha, this.hiddenAreaColorAlpha = this.opt.hiddenAreaColorAlpha, this.heading = this.opt.heading || 0, this.pitch = this.opt.pitch || 0, this.verticalFov = this.opt.verticalFov, this.horizontalFov = this.opt.horizontalFov, this.distance = 0 } startDraw(s) { let n = this; this.prompt || (this.prompt = new Prompt$1(this.viewer, this.promptStyle)), this.handler.setInputAction(function (t) { let e = n.getCatesian3FromPX(t.position, n.viewer); e && (n.startPosition ? (n.endPosition = e.clone(), n.handler && (n.handler.destroy(), n.handler = null), n.prompt && (n.prompt.destroy(), n.prompt = null)) : n.startPosition = e.clone()) }, Cesium.ScreenSpaceEventType.LEFT_CLICK), this.handler.setInputAction(function (e) { if (n.startPosition) { n.prompt.update(e.endPosition, "再次单击结束"); let t = n.getCatesian3FromPX(e.endPosition, n.viewer); var i, o; t && (n.vfPrimitive || (n.vfPrimitive = new VisualField(n.viewer, { cameraOptions: { viewerPosition: n.startPosition.clone(), visibleAreaColor: n.visibleAreaColor, visibleAreaColorAlpha: n.visibleAreaColorAlpha, hiddenAreaColor: n.hiddenAreaColor, hiddenAreaColorAlpha: n.hiddenAreaColorAlpha, horizontalFov: n.horizontalFov, verticalFov: n.verticalFov } }), n.viewer.scene.primitives.add(n.vfPrimitive)), i = Cesium.Cartographic.fromCartesian(n.startPosition.clone()), o = Cesium.Cartographic.fromCartesian(t.clone()), i = n.computeAngle(i, o), n.heading = i, n.vfPrimitive.heading = i, o = Cesium.Cartesian3.distance(n.startPosition.clone(), t.clone()), n.distance = o, n.vfPrimitive.distance = o, s && s(heading, o)) } else n.prompt.update(e.endPosition, "单击开始绘制") }, Cesium.ScreenSpaceEventType.MOUSE_MOVE) } setVisibleAreaColor(t) { t && (this.visibleAreaColor = t, this.vfPrimitive && (this.vfPrimitive.visibleAreaColor = t)) } setVisibleAreaColorAlpha(t) { t && (this.visibleAreaColorAlpha = Number(t), this.vfPrimitive && (this.vfPrimitive.visibleAreaColorAlpha = Number(t))) } setHiddenAreaColor(t) { t && (this.hiddenAreaColor = t, this.vfPrimitive && (this.vfPrimitive.hiddenAreaColor = t)) } setHiddenAreaColorAlpha(t) { t && (this.hiddenAreaColorAlpha = Number(t), this.vfPrimitive && (this.vfPrimitive.hiddenAreaColorAlpha = Number(t))) } setDistance(t) { t && (this.distance = Number(t), this.vfPrimitive && (this.vfPrimitive.distance = Number(t))) } setVerticalFov(t) { t && (this.verticalFov = Number(t), this.vfPrimitive && (this.vfPrimitive.verticalFov = Number(t))) } setHorizontalFov(t) { t && (this.horizontalFov = Number(t), this.vfPrimitive && (this.vfPrimitive.horizontalFov = Number(t))) } setHeading(t) { t && (this.heading = 0, this.vfPrimitive && (this.vfPrimitive.heading = Number(t))) } setPitch(t) { t && (this.pitch = Number(t), this.vfPrimitive && (this.vfPrimitive.pitch = Number(t))) } computeAngle(t, e) { var i, o, s; if (t && e) return i = t.longitude, t = t.latitude, o = e.longitude, e = e.latitude, s = Math.sin(o - i) * Math.cos(e), t = Math.cos(t) * Math.sin(e) - Math.sin(t) * Math.cos(e) * Math.cos(o - i), (e = 180 * (e = Math.atan2(s, t)) / Math.PI) < -180 && (e += 360), e } getCatesian3FromPX(t) { var e = this.viewer.scene.drillPick(t); this.viewer.scene.render(); let i, o = !1; for (let t = 0; t < e.length; t++)if (e[t] && e[t].primitive && e[t].primitive instanceof Cesium.Cesium3DTileset) { o = !0; break } if (o) i = this.viewer.scene.pickPosition(t); else { t = this.viewer.camera.getPickRay(t); if (!t) return null; i = this.viewer.scene.globe.pick(t, this.viewer.scene) } return i } clear() { this.vfPrimitiv && (this.viewer.scene.primitives.remove(this.vfPrimitive), this.vfPrimitive = null) } destroy() { this.clear(), this.handler && (this.handler.destroy(), this.handler = null), this.prompt && (this.prompt.destroy(), this.prompt = null) } } class Sunshine { constructor(t, e) { this.viewer = t, this.opt = e || {}, this._startTime = e.startTime || Cesium.JulianDate.fromDate((new Date).setHours(8), new Cesium.JulianDate), this._startTime instanceof Date && (this._startTime = Cesium.JulianDate.fromDate(this._startTime, new Cesium.JulianDate)), this._endTime = e.endTime, this._endTime instanceof Date && (this._endTime = Cesium.JulianDate.fromDate(this._endTime, new Cesium.JulianDate)), this.oldShouldAnimate = this.viewer.clock.shouldAnimate, this.multiplier = e.multiplier || 60 } start() { this.viewer.clock.currentTime = this._startTime.clone(), this.viewer.clock.startTime = this._startTime.clone(), this.viewer.clock.shouldAnimate = !0, this.viewer.clock.multiplier = this.multiplier, this.viewer.scene.globe.enableLighting = !0, this.viewer.shadows = !0, this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP, this._endTime && (this.viewer.clock.endTime = this._endTime.clone()) } end() { this.viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED, this.viewer.clock.shouldAnimate = this.oldShouldAnimate, this.viewer.clock.multiplier = 1 } destroy() { this.viewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED, this.viewer.clock.shouldAnimate = this.oldShouldAnimate, this.viewer.clock.multiplier = 1 } pause() { this.viewer.clock.shouldAnimate = !this.viewer.clock.shouldAnimate } get startTime() { return this._startTime } set startTime(t) { t && (this._startTime instanceof Date ? this._startTime = Cesium.JulianDate.fromDate(this._startTime, new Cesium.JulianDate) : this._startTime = t.clone(), this.start()) } get endTime() { return this._endTime } set endTime(t) { t && (this._endTime instanceof Date ? this._endTime = Cesium.JulianDate.fromDate(this._startTime, new Cesium.JulianDate) : this._endTime = t.clone(), this.start()) } } function FlowLineMaterial$1(t) { this.defaultColor = new Cesium.Color(0, 0, 0, 0), t = t || {}, this._definitionChanged = new Cesium.Event, this._color = void 0, this.color = t.color || this.defaultColor, this._duration = t.duration || 1e3, this.url = t.image, this._time = void 0, this.repeat = t.repeat || new Cesium.Cartesian2(1, 1) } function FlyLineMaterial$1(t) { this.defaultColor = new Cesium.Color(0, 0, 0, 0), this._definitionChanged = new Cesium.Event, this._color = void 0, this.color = t.color || this.defaultColor, this.duration = t.duration || 3e3, this.image = t.image, this.image || console.warn("缺少材质图片！") } function AnimateWall(t) { this._definitionChanged = new Cesium.Event, this.color = t.color, this.duration = t.duration, this._time = (new Date).getTime(), t.image || console.log("未传入材料图片！"), this.image = t.image, this.repeat = t.repeat || new Cesium.Cartesian2(5, 1), this.axisY = t.axisY } function AnimateWave(t) { this._definitionChanged = new Cesium.Event, this._color = void 0, this.defaultColor = Cesium.Color.fromCssColorString("#02ff00"), this.color = Cesium.defaultValue(t.color, this.defaultColor), this._duration = t.duration || 1e3, this._time = void 0 } FlowLineMaterial$1.prototype.getType = function (t) { return "FlowLine" }, FlowLineMaterial$1.prototype.getValue = function (t, e) { return (e = Cesium.defined(e) ? e : {}).color = Cesium.Property.getValueOrClonedDefault(this._color, t, this.defaultColor, e.color), e.image = this.url, void 0 === this._time && (this._time = (new Date).getTime()), e.time = ((new Date).getTime() - this._time) / this._duration, e.repeat = this.repeat, e }, FlowLineMaterial$1.prototype.equals = function (t) { return this === t || t instanceof FlowLineMaterial$1 && Cesium.Property.equals(this._color, t._color) && this._image._value == t._image._value && this.repeat.equals(t.repeat) }, FlyLineMaterial$1.prototype.getType = function (t) { return "FlyLine" }, FlyLineMaterial$1.prototype.getValue = function (t, e) { return Cesium.defined(e) || (e = {}), this._time || (this._time = (new Date).getTime()), e.color = Cesium.Property.getValueOrClonedDefault(this._color, t, Cesium.Color.WHITE, e.color), e.image = this.image, e.time = ((new Date).getTime() - this._time) % this.duration / this.duration, e }, FlyLineMaterial$1.prototype.equals = function (t) { return this === t || t instanceof FlyLineMaterial$1 && Cesium.Property.equals(this._color, t._color) && this._image._value == t._image._value && this.repeat.equals(t.repeat) }, AnimateWall.prototype.getType = function (t) { return "AnimateWall" }, AnimateWall.prototype.getValue = function (t, e) { return (e = Cesium.defined(e) ? e : {}).color = Cesium.Property.getValueOrClonedDefault(this._color, t, Cesium.Color.WHITE, e.color), e.image = this.image, e.time = ((new Date).getTime() - this._time) % this.duration / this.duration, e.axisY = this.axisY, e.repeat = this.repeat, e }, AnimateWall.prototype.equals = function (t) { return this === t || t instanceof AnimateWall && Cesium.Property.equals(this._color, t._color) && this._image._value == t._image._value && this.repeat.equals(t.repeat) }, AnimateWave.prototype.color = function () { return Cesium.createPropertyDescriptor("color") }, AnimateWave.prototype.getType = function () { return "AnimateWave" }, AnimateWave.prototype.getValue = function (t, e) { return (e = Cesium.defined(e) ? e : {}).color = Cesium.Property.getValueOrClonedDefault(this._color, t, this.color, e.color), void 0 === this._time && (this._time = (new Date).getTime()), e.time = ((new Date).getTime() - this._time) / this._duration, e }, AnimateWave.prototype.equals = function (t) { return this === t || t instanceof AnimateWave && Cesium.Property.equals(this._color, t._color) }; let Cesium$1 = require("cesium/Cesium.js"); function registerAnimate() {
    return Object.defineProperties(FlowLineMaterial$1.prototype, { isConstant: { get: function () { return !1 } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: Cesium$1.createPropertyDescriptor("color") }), Cesium$1.Material._materialCache.addMaterial("FlowLine", { fabric: { type: "FlowLine", uniforms: { color: new Cesium$1.Color(1, 0, 0, 1), image: "", time: 0, repeat: new Cesium$1.Cartesian2(1, 1) }, source: "czm_material czm_getMaterial(czm_materialInput materialInput)\n                {\n                    czm_material material = czm_getDefaultMaterial(materialInput);\n                    vec2 st = repeat * materialInput.st;\n                    vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));\n                    if(color.a == 0.0)\n                    {\n                        material.alpha = colorImage.a;\n                        material.diffuse = colorImage.rgb; \n                    }\n                    else\n                    {\n                        material.alpha = colorImage.a * color.a;\n                        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \n                    }\n                    return material;\n                }" }, translucent: function () { return !0 } }), Object.defineProperties(FlyLineMaterial$1.prototype, { isConstant: { get: function () { return !1 } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: Cesium$1.createPropertyDescriptor("color") }), Cesium$1.Material._materialCache.addMaterial("FlyLine", {
        fabric: {
            type: "FlyLine", uniforms: { color: new Cesium$1.Color(1, 0, 0, .5), image: "", time: 0 }, source: `
            czm_material czm_getMaterial(czm_materialInput materialInput)
            {
                    czm_material material = czm_getDefaultMaterial(materialInput);
                    vec2 st = materialInput.st;
                    vec4 colorImage = texture2D(image, vec2(fract(st.s - time), st.t));
                    material.alpha = colorImage.a * color.a;
                    material.diffuse = (colorImage.rgb+color.rgb)/2.0;
                    return material;
                }
    `}, translucent: function (t) { return !0 }
    }), Object.defineProperties(AnimateWall.prototype, { isConstant: { get: function () { return !1 } }, definitionChanged: { get: function () { return this._definitionChanged } }, color: Cesium$1.createPropertyDescriptor("color") }), Cesium$1.Material._materialCache.addMaterial("AnimateWall", { fabric: { type: "AnimateWall", uniforms: { color: new Cesium$1.Color(1, 1, 1, .5), image: "", time: 0, repeat: new Cesium$1.Cartesian2(5, 1), axisY: !1 }, source: "czm_material czm_getMaterial(czm_materialInput materialInput)\n                            {\n                                czm_material material = czm_getDefaultMaterial(materialInput);\n                                vec2 st = repeat * materialInput.st;\n                                vec4 colorImage = texture2D(image, vec2(fract((axisY?st.s:st.t) - time), st.t));\n                                if(color.a == 0.0)\n                                {\n                                    material.alpha = colorImage.a;\n                                    material.diffuse = colorImage.rgb; \n                                }\n                                else\n                                {\n                                    material.alpha = colorImage.a * color.a;\n                                    material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \n                                }\n                                material.emission = colorImage.rgb;\n                                return material;\n                            }" }, translucent: function (t) { return !0 } }), Object.defineProperties(AnimateWave.prototype, { isConstant: { get: function () { return !1 } }, definitionChanged: { get: function () { return this._definitionChanged } } }), Cesium$1.Material._materialCache.addMaterial("AnimateWave", {
        fabric: {
            type: "AnimateWave", uniforms: { color: new Cesium$1.Color(1, 0, 0, 1), time: 10 }, source: `czm_material czm_getMaterial(czm_materialInput materialInput)
                {
                    czm_material material = czm_getDefaultMaterial(materialInput);
                    material.diffuse = 1.5 * color.rgb;
                    vec2 st = materialInput.st;
                    float dis = distance(st, vec2(0.5, 0.5));
                    float per = fract(time);
                    if(dis > per * 0.5){
                        discard;
                    }else {
                        material.alpha = color.a  * dis / per / 2.0;
                    }
                    return material;
                }
            `}, translucent: function () { return !0 }
    }), { FlowLineMaterial: FlowLineMaterial$1, FlyLineMaterial: FlyLineMaterial$1, AnimateWall: AnimateWall, AnimateWave: AnimateWave }
} let analysis = { VisualTool: VisualTool, Sunshine: Sunshine }, weather = { fog: fog, rain: rain, snow: snow }, rganimate = registerAnimate(), animate = { Wall: rganimate.AnimateWall, FlowLine: rganimate.FlowLineMaterial }; class MapViewer { constructor(t, e) { t && (this.domId = t, this.opt = e || {}, this._viewer = null, this.baseLayerTool = null, this.operateLayerTool = null, this.operatePlotTool = null, this.rightTool = null, this.bottomLnglatTool = null, this.popupTooltipTool = null, this.createViewer(), this.loadbaseLayers(), this.loadOperateLayers(), this.terrainUrl = "", t = this.opt.map["terrain"], t && t.url && t.show && this.loadTerrain(t.url), this.opt.map.bottomLnglatTool && this.openBottomLnglatTool(), this.opt.map.rightTool && this.openRightTool(), this.opt.map.popupTooltipTool && this.openPopupTooltip(), this.opt.map.navigationTool && this.openNavigationTool(), this.opt.map.worldAnimate ? this.openWorldAnimate() : this.opt.map.cameraView && cUtil$1.setCameraView(this.opt.map.cameraView, this._viewer)) } get viewer() { return this._viewer } createViewer() { var t = this.opt.map["viewerConfig"]; this._viewer = new window.Cesium.Viewer(this.domId, t), this._viewer.imageryLayers.removeAll(), this._viewer._cesiumWidget._creditContainer.style.display = "none", this._viewer.mapConfig = this.opt, this._viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK), this.viewer.scene.globe.depthTestAgainstTerrain = this.opt.map.depthTestAgainstTerrain } loadbaseLayers() { var i = (this.opt || [])["baseLayers"]; for (let e = 0; e < i.length; e++) { let t = i[e]; if (!t.type) return void console.log("缺少基础图层的图层类型", t); "group" != t.type && (t.id = t.id || (new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0), this.baseLayerTool || (this.baseLayerTool = new LayerTool(this._viewer)), this.baseLayerTool.add(t)) } } loadOperateLayers() { var t = (this.opt || [])["operateLayers"]; let s = []; !function i(o) { for (let e = 0; e < o.length; e++) { let t = o[e]; t.id = t.id || (new Date).getTime() + "" + Number(1e3 * Math.random()).toFixed(0), t.alpha = null == t.alpha ? 1 : t.alpha, t.children && 0 < t.children.length ? i(t.children) : s.push(t) } }(t); for (let e = 0; e < s.length; e++) { let t = s[e]; if (!t.type) return void console.log("缺少基础图层的图层类型", t); "group" != t.type && ("plot" == t.type && t.show ? (this.operatePlotTool || (this.operatePlotTool = new DrawTool(this._viewer, { canEdit: !1 })), t.type = t.plotType, this.operatePlotTool.createByPositions(t)) : (this.operateLayerTool || (this.operateLayerTool = new LayerTool(this._viewer)), this.operateLayerTool.add(t))) } } loadTerrain(t) { this._viewer.scene.terrainProvider = new Cesium.EllipsoidTerrainProvider({}), (this.terrainUrl = t) && (t = new Cesium.CesiumTerrainProvider({ url: t }), this._viewer.scene.terrainProvider = t) } setTerrainVisible(t) { t ? this.loadTerrain(this.terrainUrl) : this._viewer.scene.terrainProvider = new Cesium.EllipsoidTerrainProvider({}), this._viewer.scene.render() } openRightTool() { this.rightTool || (this.rightTool = new RightTool(this.viewer, {})) } closeRightTool() { this.rightTool && (this.rightTool.destroy(), this.rightTool = null) } openPopupTooltip() { this.popupTooltip || (this.popupTooltip = new PopupTooltipTool(this.viewer, {}), this.popupTooltip.autoBindTooltip(), this.popupTooltip.autoBindPopup()) } openBottomLnglatTool() { this.bottomLnglatTool || (this.bottomLnglatTool = new LatlngNavigation(this._viewer)) } closeBottomLnglatTool() { this.bottomLnglatTool && (this.bottomLnglatTool.destroy(), this.bottomLnglatTool = null) } openWorldAnimate() { let t = this; easy3dView.setRotate({ x: this.opt.map.cameraView.x, y: this.opt.map.cameraView.y }, function () { t.opt.map.cameraView && cUtil$1.setCameraView(t.opt.map.cameraView) }) } openNavigationTool() { new CesiumNavigation(this._viewer, { enableCompass: !0, enableZoomControls: !0, enableDistanceLegend: !0, enableCompassOuterRing: !0, view: this.viewer.mapConfig.map && this.viewer.mapConfig.map.cameraView }) } destroy() { this.baseLayerTool && (this.baseLayerTool.destroy(), this.baseLayerTool = null), this.operateLayerTool && (this.operateLayerTool.destroy(), this.operateLayerTool = null), this.operatePlotTool && (this.operatePlotTool.destroy(), this.operatePlotTool = null), this.bottomLnglatTool && (this.bottomLnglatTool.destroy(), this.bottomLnglatTool = null), this._viewer && (this._viewer.destroy(), this._viewer = null) } } var easy3d_export = { cUtil: cUtil$1, cTool: cTool, MapViewer: MapViewer, DrawTool: DrawTool, LayerTool: LayerTool, MeasureTool: MeasureTool, Prompt: Prompt$1, gadgets: gadgets, RoamTool: RoamTool, ZoomTool: ZoomTool, OverviewMap: OverviewMap, weather: weather, animate: animate, analysis: analysis }; module.exports = easy3d_export;
